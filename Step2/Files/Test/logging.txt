---------------------------------------------------------------------------------------------------
/** 
 * Recent file list.
 * @author Slava Pestov
 * @version $Id: logging.txt,v 1.1 2016/04/20 11:32:51 nziragch Exp $
 */
public class BufferHistory {
  public static Entry getEntry(  String path){
    Iterator iter=history.iterator();
    while (iter.hasNext()) {
      Entry entry=(Entry)iter.next();
      if (pathsCaseInsensitive) {
        if (entry.path.equalsIgnoreCase(path))         return entry;
      }
 else {
        if (entry.path.equals(path))         return entry;
      }
    }
    return null;
  }
  public static void setEntry(  String path,  int caret,  Selection[] selection,  String encoding){
    removeEntry(path);
    addEntry(new Entry(path,caret,selectionToString(selection),encoding));
    EditBus.send(new DynamicMenuChanged("recent-files"));
  }
  /** 
 * @since jEdit 4.2pre2
 */
  public static List getHistory(){
    return history;
  }
  /** 
 * @deprecated Call {@link #getHistory()} instead.
 */
  public static Vector getBufferHistory(){
    Vector retVal=new Vector(history.size());
    Iterator iter=history.iterator();
    while (iter.hasNext())     retVal.add(iter.next());
    return retVal;
  }
  public static void load(){
    String settingsDirectory=jEdit.getSettingsDirectory();
    if (settingsDirectory == null)     return;
    File recent=new File(MiscUtilities.constructPath(settingsDirectory,"recent.xml"));
    if (!recent.exists())     return;
    recentModTime=recent.lastModified();
    Log.log(Log.MESSAGE,BufferHistory.class,"Loading recent.xml");
    RecentHandler handler=new RecentHandler();
    XmlParser parser=new XmlParser();
    Reader in=null;
    parser.setHandler(handler);
    try {
      in=new BufferedReader(new FileReader(recent));
      parser.parse(null,null,in);
    }
 catch (    XmlException xe) {
      int line=xe.getLine();
      String message=xe.getMessage();
      Log.log(Log.ERROR,BufferHistory.class,recent + ":" + line+ ": "+ message);
    }
catch (    FileNotFoundException fnf) {
    }
catch (    Exception e) {
      Log.log(Log.ERROR,BufferHistory.class,e);
    }
 finally {
      try {
        if (in != null)         in.close();
      }
 catch (      IOException io) {
        Log.log(Log.ERROR,BufferHistory.class,io);
      }
    }
  }
  public static void save(){
    String settingsDirectory=jEdit.getSettingsDirectory();
    if (settingsDirectory == null)     return;
    File file1=new File(MiscUtilities.constructPath(settingsDirectory,"#recent.xml#save#"));
    File file2=new File(MiscUtilities.constructPath(settingsDirectory,"recent.xml"));
    if (file2.exists() && file2.lastModified() != recentModTime) {
      Log.log(Log.WARNING,BufferHistory.class,file2 + " changed on disk; will not save recent" + " files");
      return;
    }
    jEdit.backupSettingsFile(file2);
    Log.log(Log.MESSAGE,BufferHistory.class,"Saving " + file1);
    String lineSep=System.getProperty("line.separator");
    boolean ok=false;
    BufferedWriter out=null;
    try {
      out=new BufferedWriter(new FileWriter(file1));
      out.write("<?xml version=\"1.0\"?>");
      out.write(lineSep);
      out.write("<!DOCTYPE RECENT SYSTEM \"recent.dtd\">");
      out.write(lineSep);
      out.write("<RECENT>");
      out.write(lineSep);
      Iterator iter=history.iterator();
      while (iter.hasNext()) {
        out.write("<ENTRY>");
        out.write(lineSep);
        Entry entry=(Entry)iter.next();
        out.write("<PATH>");
        out.write(MiscUtilities.charsToEntities(entry.path));
        out.write("</PATH>");
        out.write(lineSep);
        out.write("<CARET>");
        out.write(String.valueOf(entry.caret));
        out.write("</CARET>");
        out.write(lineSep);
        if (entry.selection != null && entry.selection.length() > 0) {
          out.write("<SELECTION>");
          out.write(entry.selection);
          out.write("</SELECTION>");
          out.write(lineSep);
        }
        if (entry.encoding != null) {
          out.write("<ENCODING>");
          out.write(entry.encoding);
          out.write("</ENCODING>");
          out.write(lineSep);
        }
        out.write("</ENTRY>");
        out.write(lineSep);
      }
      out.write("</RECENT>");
      out.write(lineSep);
      out.close();
      ok=true;
    }
 catch (    Exception e) {
      Log.log(Log.ERROR,BufferHistory.class,e);
    }
 finally {
      try {
        if (out != null)         out.close();
      }
 catch (      IOException e) {
      }
    }
    if (ok) {
      file2.delete();
      file1.renameTo(file2);
    }
    recentModTime=file2.lastModified();
  }
  private static LinkedList history;
  private static boolean pathsCaseInsensitive;
  private static long recentModTime;
static {
    history=new LinkedList();
    pathsCaseInsensitive=OperatingSystem.isDOSDerived() || OperatingSystem.isMacOS();
  }
  static void addEntry(  Entry entry){
    history.addFirst(entry);
    int max=jEdit.getIntegerProperty("recentFiles",50);
    while (history.size() > max)     history.removeLast();
  }
  static void removeEntry(  String path){
    Iterator iter=history.iterator();
    while (iter.hasNext()) {
      Entry entry=(Entry)iter.next();
      if (pathsCaseInsensitive) {
        if (entry.path.equalsIgnoreCase(path)) {
          iter.remove();
          return;
        }
      }
 else {
        if (entry.path.equals(path)) {
          iter.remove();
          return;
        }
      }
    }
  }
  private static String selectionToString(  Selection[] s){
    if (s == null)     return null;
    StringBuffer buf=new StringBuffer();
    for (int i=0; i < s.length; i++) {
      if (i != 0)       buf.append(' ');
      Selection sel=s[i];
      if (sel instanceof Selection.Range)       buf.append("range ");
 else       buf.append("rect ");
      buf.append(sel.getStart());
      buf.append(' ');
      buf.append(sel.getEnd());
    }
    return buf.toString();
  }
  private static Selection[] stringToSelection(  String s){
    if (s == null)     return null;
    Vector selection=new Vector();
    StringTokenizer st=new StringTokenizer(s);
    while (st.hasMoreTokens()) {
      String type=st.nextToken();
      int start=Integer.parseInt(st.nextToken());
      int end=Integer.parseInt(st.nextToken());
      if (end < start) {
        continue;
      }
      Selection sel;
      if (type.equals("range"))       sel=new Selection.Range(start,end);
 else       sel=new Selection.Rect(start,end);
      selection.addElement(sel);
    }
    Selection[] returnValue=new Selection[selection.size()];
    selection.copyInto(returnValue);
    return returnValue;
  }
  /** 
 * Recent file list entry.
 */
public static class Entry {
    public String path;
    public int caret;
    public String selection;
    public String encoding;
    public Selection[] getSelection(){
      return stringToSelection(selection);
    }
    public Entry(    String path,    int caret,    String selection,    String encoding){
      this.path=path;
      this.caret=caret;
      this.selection=selection;
      this.encoding=encoding;
    }
    public String toString(){
      return path + ": " + caret;
    }
  }
static class RecentHandler extends HandlerBase {
    public void endDocument() throws java.lang.Exception {
      int max=jEdit.getIntegerProperty("recentFiles",50);
      while (history.size() > max)       history.removeLast();
    }
    public Object resolveEntity(    String publicId,    String systemId){
      if ("recent.dtd".equals(systemId)) {
        return new StringReader("<!-- -->");
      }
      return null;
    }
    public void doctypeDecl(    String name,    String publicId,    String systemId) throws Exception {
      if ("RECENT".equals(name))       return;
      Log.log(Log.ERROR,this,"recent.xml: DOCTYPE must be RECENT");
    }
    public void endElement(    String name){
      if (name.equals("ENTRY")) {
        history.addLast(new Entry(path,caret,selection,encoding));
        path=null;
        caret=0;
        selection=null;
        encoding=null;
      }
 else       if (name.equals("PATH"))       path=charData;
 else       if (name.equals("CARET"))       caret=Integer.parseInt(charData);
 else       if (name.equals("SELECTION"))       selection=charData;
 else       if (name.equals("ENCODING"))       encoding=charData;
    }
    public void charData(    char[] ch,    int start,    int length){
      charData=new String(ch,start,length);
    }
    private String path;
    private int caret;
    private String selection;
    private String encoding;
    private String charData;
  }
}

---------------------------------------------------------------------------------------------------
static class RecentHandler extends HandlerBase {
  public void endDocument() throws java.lang.Exception {
    int max=jEdit.getIntegerProperty("recentFiles",50);
    while (history.size() > max)     history.removeLast();
  }
  public Object resolveEntity(  String publicId,  String systemId){
    if ("recent.dtd".equals(systemId)) {
      return new StringReader("<!-- -->");
    }
    return null;
  }
  public void doctypeDecl(  String name,  String publicId,  String systemId) throws Exception {
    if ("RECENT".equals(name))     return;
    Log.log(Log.ERROR,this,"recent.xml: DOCTYPE must be RECENT");
  }
  public void endElement(  String name){
    if (name.equals("ENTRY")) {
      history.addLast(new Entry(path,caret,selection,encoding));
      path=null;
      caret=0;
      selection=null;
      encoding=null;
    }
 else     if (name.equals("PATH"))     path=charData;
 else     if (name.equals("CARET"))     caret=Integer.parseInt(charData);
 else     if (name.equals("SELECTION"))     selection=charData;
 else     if (name.equals("ENCODING"))     encoding=charData;
  }
  public void charData(  char[] ch,  int start,  int length){
    charData=new String(ch,start,length);
  }
  private String path;
  private int caret;
  private String selection;
  private String encoding;
  private String charData;
}


---------------------------------------------------------------------------------------------------
/** 
 * jEdit's global event notification mechanism.<p>
 * Plugins register with the EditBus to receive messages reflecting
 * changes in the application's state, including changes in buffers,
 * views and edit panes, changes in the set of properties maintained
 * by the application, and the closing of the application.<p>
 * The EditBus maintains a list of objects that have requested to receive
 * messages. When a message is sent using this class, all registered
 * components receive it in turn. Classes for objects that subscribe to
 * the EditBus must implement the {@link EBComponent} interface, which
 * defines the single method {@link EBComponent#handleMessage(EBMessage)}.<p>
 * A plugin core class that extends the{@link EBPlugin} abstract class (and whose name ends with
 * <code>Plugin</code> for identification purposes) will automatically be
 * added to the EditBus during jEdit's startup routine.  Any other
 * class - for example, a dockable window that needs to receive
 * notification of buffer changes - must perform its own registration by calling{@link #addToBus(EBComponent)} during its initialization.
 * A convenient place to register in a class derived from <code>JComponent</code>
 * would be in an implementation of the <code>JComponent</code> method
 * <code>addNotify()</code>.<p>
 * Message types sent by jEdit can be found in the{@link org.gjt.sp.jedit.msg} package.<p>
 * Plugins can also send their own messages - any object can send a message to
 * the EditBus by calling the static method {@link #send(EBMessage)}.
 * Most plugins, however, only concern themselves with receiving, not
 * sending, messages.
 * @see org.gjt.sp.jedit.EBComponent
 * @see org.gjt.sp.jedit.EBMessage
 * @author Slava Pestov
 * @author John Gellene (API documentation)
 * @version $Id: logging.txt,v 1.1 2016/04/20 11:32:51 nziragch Exp $
 * @since jEdit 2.2pre6
 */
public class EditBus {
  /** 
 * Adds a component to the bus. It will receive all messages sent
 * on the bus.
 * @param comp The component to add
 */
  public static void addToBus(  EBComponent comp){
synchronized (components) {
      components.add(comp);
      copyComponents=null;
    }
  }
  /** 
 * Removes a component from the bus.
 * @param comp The component to remove
 */
  public static void removeFromBus(  EBComponent comp){
synchronized (components) {
      components.remove(comp);
      copyComponents=null;
    }
  }
  /** 
 * Returns an array of all components connected to the bus.
 */
  public static EBComponent[] getComponents(){
synchronized (components) {
      if (copyComponents == null) {
        copyComponents=(EBComponent[])components.toArray(new EBComponent[components.size()]);
      }
      return copyComponents;
    }
  }
  /** 
 * Sends a message to all components on the bus in turn.
 * @param message The message
 */
  public static void send(  EBMessage message){
    Log.log(Log.DEBUG,EditBus.class,message.toString());
    EBComponent[] comps=getComponents();
    for (int i=0; i < comps.length; i++) {
      try {
        EBComponent comp=comps[i];
        if (Debug.EB_TIMER) {
          long start=System.currentTimeMillis();
          comp.handleMessage(message);
          long time=(System.currentTimeMillis() - start);
          if (time != 0) {
            Log.log(Log.DEBUG,EditBus.class,comp + ": " + time+ " ms");
          }
        }
 else         comps[i].handleMessage(message);
      }
 catch (      Throwable t) {
        Log.log(Log.ERROR,EditBus.class,"Exception" + " while sending message on EditBus:");
        Log.log(Log.ERROR,EditBus.class,t);
      }
    }
  }
  private static ArrayList components=new ArrayList();
  private static EBComponent[] copyComponents;
  private EditBus(){
  }
}


---------------------------------------------------------------------------------------------------
/** 
 * A class loader implementation that loads classes from JAR files. All
 * instances share the same set of classes.
 * @author Slava Pestov
 * @version $Id: logging.txt,v 1.1 2016/04/20 11:32:51 nziragch Exp $
 */
public class JARClassLoader extends ClassLoader {
  /** 
 * This constructor creates a class loader for loading classes from all
 * plugins. For example BeanShell uses one of these so that scripts can
 * use plugin classes.
 */
  public JARClassLoader(){
    id=INDEX++;
    live++;
  }
  /** 
 * @exception ClassNotFoundException if the class could not be found
 */
  public Class loadClass(  String clazz,  boolean resolveIt) throws ClassNotFoundException {
    Object obj=classHash.get(clazz);
    if (obj == NO_CLASS) {
      throw new ClassNotFoundException(clazz);
    }
 else     if (obj instanceof JARClassLoader) {
      JARClassLoader classLoader=(JARClassLoader)obj;
      return classLoader._loadClass(clazz,resolveIt);
    }
    try {
      Class cls;
      ClassLoader parentLoader=getClass().getClassLoader();
      if (parentLoader != null)       cls=parentLoader.loadClass(clazz);
 else       cls=findSystemClass(clazz);
      return cls;
    }
 catch (    ClassNotFoundException cnf) {
      classHash.put(clazz,NO_CLASS);
      throw cnf;
    }
  }
  public InputStream getResourceAsStream(  String name){
    if (jar == null)     return null;
    try {
      ZipFile zipFile=jar.getZipFile();
      ZipEntry entry=zipFile.getEntry(name);
      if (entry == null)       return getSystemResourceAsStream(name);
 else       return zipFile.getInputStream(entry);
    }
 catch (    IOException io) {
      Log.log(Log.ERROR,this,io);
      return null;
    }
  }
  public URL getResource(  String name){
    if (jar == null)     return null;
    try {
      ZipFile zipFile=jar.getZipFile();
      ZipEntry entry=zipFile.getEntry(name);
      if (entry == null)       return getSystemResource(name);
 else       return new URL(getResourceAsPath(name));
    }
 catch (    IOException io) {
      Log.log(Log.ERROR,this,io);
      return null;
    }
  }
  public String getResourceAsPath(  String name){
    if (jar == null)     return null;
    if (!name.startsWith("/"))     name="/" + name;
    return "jeditresource:/" + MiscUtilities.getFileName(jar.getPath()) + "!"+ name;
  }
  /** 
 * @deprecated Call <code>PluginJAR.getZipFile()</code> instead.
 */
  public ZipFile getZipFile(){
    try {
      return jar.getZipFile();
    }
 catch (    IOException io) {
      Log.log(Log.ERROR,this,io);
      return null;
    }
  }
  /** 
 * For debugging.
 */
  public static void dump(){
    Log.log(Log.DEBUG,JARClassLoader.class,"Total instances created: " + INDEX);
    Log.log(Log.DEBUG,JARClassLoader.class,"Live instances: " + live);
synchronized (classHash) {
      Iterator entries=classHash.entrySet().iterator();
      while (entries.hasNext()) {
        Map.Entry entry=(Map.Entry)entries.next();
        if (entry.getValue() != NO_CLASS) {
          Log.log(Log.DEBUG,JARClassLoader.class,entry.getKey() + " ==> " + entry.getValue());
        }
      }
    }
  }
  public String toString(){
    if (jar == null)     return "<anonymous>(" + id + ")";
 else     return jar.getPath() + " (" + id+ ")";
  }
  protected void finalize(){
    live--;
  }
  /** 
 * @since jEdit 4.2pre1
 */
  JARClassLoader(  PluginJAR jar){
    this();
    this.jar=jar;
  }
  void activate(){
    String[] classes=jar.getClasses();
    if (classes != null) {
      for (int i=0; i < classes.length; i++) {
        classHash.put(classes[i],this);
      }
    }
  }
  void deactivate(){
    String[] classes=jar.getClasses();
    if (classes == null)     return;
    for (int i=0; i < classes.length; i++) {
      Object loader=classHash.get(classes[i]);
      if (loader == this)       classHash.remove(classes[i]);
 else       ;
    }
  }
  private static final Object NO_CLASS=new Object();
  private static int INDEX;
  private static int live;
  private static Hashtable classHash=new Hashtable();
  private int id;
  private PluginJAR jar;
  /** 
 * Load class from this JAR only.
 */
  private synchronized Class _loadClass(  String clazz,  boolean resolveIt) throws ClassNotFoundException {
    jar.activatePlugin();
synchronized (this) {
      Class cls=findLoadedClass(clazz);
      if (cls != null) {
        if (resolveIt)         resolveClass(cls);
        return cls;
      }
      String name=MiscUtilities.classToFile(clazz);
      try {
        ZipFile zipFile=jar.getZipFile();
        ZipEntry entry=zipFile.getEntry(name);
        if (entry == null)         throw new ClassNotFoundException(clazz);
        InputStream in=zipFile.getInputStream(entry);
        int len=(int)entry.getSize();
        byte[] data=new byte[len];
        int success=0;
        int offset=0;
        while (success < len) {
          len-=success;
          offset+=success;
          success=in.read(data,offset,len);
          if (success == -1) {
            Log.log(Log.ERROR,this,"Failed to load class " + clazz + " from "+ zipFile.getName());
            throw new ClassNotFoundException(clazz);
          }
        }
        cls=defineClass(clazz,data,0,data.length);
        if (resolveIt)         resolveClass(cls);
        return cls;
      }
 catch (      IOException io) {
        Log.log(Log.ERROR,this,io);
        throw new ClassNotFoundException(clazz);
      }
    }
  }
}

---------------------------------------------------------------------------------------------------
class ActionListHandler extends HandlerBase {
  ActionListHandler(  String path,  ActionSet actionSet){
    this.path=path;
    this.actionSet=actionSet;
    stateStack=new Stack();
  }
  public Object resolveEntity(  String publicId,  String systemId){
    if ("actions.dtd".equals(systemId)) {
      return new StringReader("<!-- -->");
    }
    return null;
  }
  public void attribute(  String aname,  String value,  boolean isSpecified){
    aname=(aname == null) ? null : aname.intern();
    value=(value == null) ? null : value.intern();
    if (aname == "NAME")     actionName=value;
 else     if (aname == "NO_REPEAT")     noRepeat=(value == "TRUE");
 else     if (aname == "NO_RECORD")     noRecord=(value == "TRUE");
 else     if (aname == "NO_REMEMBER_LAST")     noRememberLast=(value == "TRUE");
  }
  public void doctypeDecl(  String name,  String publicId,  String systemId) throws Exception {
    if ("ACTIONS".equals(name))     return;
    Log.log(Log.ERROR,this,path + ": DOCTYPE must be ACTIONS");
  }
  public void charData(  char[] c,  int off,  int len){
    String tag=peekElement();
    String text=new String(c,off,len);
    if (tag == "CODE") {
      code=text;
    }
 else     if (tag == "IS_SELECTED") {
      isSelected=text;
    }
  }
  public void startElement(  String tag){
    tag=pushElement(tag);
    if (tag == "ACTION") {
      code=null;
      isSelected=null;
    }
  }
  public void endElement(  String name){
    if (name == null)     return;
    String tag=peekElement();
    if (name.equals(tag)) {
      if (tag == "ACTION") {
        actionSet.addAction(new BeanShellAction(actionName,code,isSelected,noRepeat,noRecord,noRememberLast));
        noRepeat=noRecord=noRememberLast=false;
      }
      popElement();
    }
 else {
      throw new InternalError();
    }
  }
  public void startDocument(){
    try {
      pushElement(null);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  private String path;
  private ActionSet actionSet;
  private String actionName;
  private String code;
  private String isSelected;
  private boolean noRepeat;
  private boolean noRecord;
  private boolean noRememberLast;
  private Stack stateStack;
  private String pushElement(  String name){
    name=(name == null) ? null : name.intern();
    stateStack.push(name);
    return name;
  }
  private String peekElement(){
    return (String)stateStack.peek();
  }
  private String popElement(){
    return (String)stateStack.pop();
  }
}


---------------------------------------------------------------------------------------------------
/** 
 * 'Wrap' EditActions in this class to turn them into AWT
 * ActionListeners, that can be attached to buttons, menu items, etc.
 */
public static class Wrapper implements ActionListener {
  /** 
 * Creates a new action listener wrapper.
 * @since jEdit 4.2pre1
 */
  public Wrapper(  ActionContext context,  String actionName){
    this.context=context;
    this.actionName=actionName;
  }
  /** 
 * Called when the user selects this action from a menu.
 * It passes the action through the{@link org.gjt.sp.jedit.gui.InputHandler#invokeAction(EditAction)}method, which performs any recording or repeating.
 * @param evt The action event
 */
  public void actionPerformed(  ActionEvent evt){
    EditAction action=context.getAction(actionName);
    if (action == null) {
      Log.log(Log.WARNING,this,"Unknown action: " + actionName);
    }
 else     context.invokeAction(evt,action);
  }
  private ActionContext context;
  private String actionName;
}


---------------------------------------------------------------------------------------------------
/** 
 * Plugins extending this class are automatically added to the EditBus.
 * Otherwise, this class is identical to the {@link EditPlugin}class.
 * @see org.gjt.sp.jedit.EditBus
 * @see org.gjt.sp.jedit.EBComponent
 * @see org.gjt.sp.jedit.EBMessage
 * @author Slava Pestov
 * @version $Id: logging.txt,v 1.1 2016/04/20 11:32:51 nziragch Exp $
 */
public abstract class EBPlugin extends EditPlugin implements EBComponent {
  /** 
 * Handles a message sent on the EditBus.
 */
  public void handleMessage(  EBMessage message){
    EditBus.removeFromBus(this);
    if (seenWarning)     return;
    seenWarning=true;
    Log.log(Log.WARNING,this,getClassName() + " should extend" + " EditPlugin not EBPlugin since it has an empty"+ " handleMessage()");
  }
  protected EBPlugin(){
  }
  private boolean seenWarning;
}
---------------------------------------------------------------------------------------------------
/** 
 * A generic way for plugins to provide various API extensions.<p>
 * Services are loaded from files named <code>services.xml</code> inside the
 * plugin JAR. A service definition file has the following form:
 * <pre>&lt;?xml version="1.0"?&gt;
 * &lt;!DOCTYPE SERVICES SYSTEM "services.dtd"&gt;
 * &lt;SERVICES&gt;
 * &lt;SERVICE NAME="service name" CLASS="fully qualified class name"&gt;
 * // BeanShell code evaluated when the sevice is first activated
 * &lt;/SERVICE&gt;
 * &lt;/SERVICES&gt;</pre>
 * The following elements are valid:
 * <ul>
 * <li>
 * <code>SERVICES</code> is the top-level element and refers
 * to the set of services offered by the plugin.
 * </li>
 * <li>
 * A <code>SERVICE</code> contains the data for a particular service
 * activation.
 * It has two attributes, both required: <code>NAME</code> and
 * <code>CLASS</code>. The <code>CLASS</code> attribute must be the name of
 * a known sevice type; see below.
 * </li>
 * <li>
 * A <code>SERVICE</code> element should the BeanShell code that returns a
 * new instance of the named class. Note that this code can return
 * <code>null</code>.
 * </li>
 * </ul>
 * The jEdit core defines the following service types:
 * <ul>
 * <li>{@link org.gjt.sp.jedit.buffer.FoldHandler}</li>
 * <li>{@link org.gjt.sp.jedit.io.VFS}</li>
 * </ul>
 * Plugins may provide more.<p>
 * To have your plugin accept services, no extra steps are needed other than
 * a piece of code somewhere that calls {@link #getServiceNames(String)} and{@link #getService(String,String)}.
 * @see BeanShell
 * @see PluginJAR
 * @since jEdit 4.2pre1
 * @author Slava Pestov
 * @version $Id: logging.txt,v 1.1 2016/04/20 11:32:51 nziragch Exp $
 */
public class ServiceManager {
  /** 
 * Loads a <code>services.xml</code> file.
 * @since jEdit 4.2pre1
 */
  public static void loadServices(  PluginJAR plugin,  URL uri,  PluginJAR.PluginCacheEntry cache){
    Reader in=null;
    try {
      Log.log(Log.DEBUG,jEdit.class,"Loading services from " + uri);
      ServiceListHandler dh=new ServiceListHandler(plugin,uri);
      XmlParser parser=new XmlParser();
      parser.setHandler(dh);
      in=new BufferedReader(new InputStreamReader(uri.openStream()));
      parser.parse(null,null,in);
      if (cache != null)       cache.cachedServices=dh.getCachedServices();
    }
 catch (    XmlException xe) {
      int line=xe.getLine();
      String message=xe.getMessage();
      Log.log(Log.ERROR,ServiceManager.class,uri + ":" + line+ ": "+ message);
    }
catch (    Exception e) {
      Log.log(Log.ERROR,ServiceManager.class,e);
    }
 finally {
      try {
        if (in != null)         in.close();
      }
 catch (      IOException io) {
        Log.log(Log.ERROR,ServiceManager.class,io);
      }
    }
  }
  /** 
 * Removes all services belonging to the specified plugin.
 * @param plugin The plugin
 * @since jEdit 4.2pre1
 */
  public static void unloadServices(  PluginJAR plugin){
    Iterator descriptors=serviceMap.keySet().iterator();
    while (descriptors.hasNext()) {
      Descriptor d=(Descriptor)descriptors.next();
      if (d.plugin == plugin)       descriptors.remove();
    }
  }
  /** 
 * Registers a service. Plugins should provide a 
 * <code>services.xml</code> file instead of calling this directly.
 * @param clazz The service class
 * @param name The service name
 * @param code BeanShell code to create an instance of this
 * @param plugin The plugin JAR, or null if this is a built-in service
 * @since jEdit 4.2pre1
 */
  public static void registerService(  String clazz,  String name,  String code,  PluginJAR plugin){
    Descriptor d=new Descriptor(clazz,name,code,plugin);
    serviceMap.put(d,d);
  }
  /** 
 * Unregisters a service.
 * @param clazz The service class
 * @param name The service name
 * @since jEdit 4.2pre1
 */
  public static void unregisterService(  String clazz,  String name){
    Descriptor d=new Descriptor(clazz,name);
    serviceMap.remove(d);
  }
  /** 
 * Returns all known service class types.
 * @since jEdit 4.2pre1
 */
  public static String[] getServiceTypes(){
    HashSet returnValue=new HashSet();
    Iterator descriptors=serviceMap.keySet().iterator();
    while (descriptors.hasNext()) {
      Descriptor d=(Descriptor)descriptors.next();
      returnValue.add(d.clazz);
    }
    return (String[])returnValue.toArray(new String[returnValue.size()]);
  }
  /** 
 * Returns the names of all registered services with the given
 * class. For example, calling this with a parameter of
 * "org.gjt.sp.jedit.io.VFS" returns all known virtual file
 * systems.
 * @param clazz The class name
 * @since jEdit 4.2pre1
 */
  public static String[] getServiceNames(  String clazz){
    ArrayList returnValue=new ArrayList();
    Iterator descriptors=serviceMap.keySet().iterator();
    while (descriptors.hasNext()) {
      Descriptor d=(Descriptor)descriptors.next();
      if (d.clazz.equals(clazz))       returnValue.add(d.name);
    }
    return (String[])returnValue.toArray(new String[returnValue.size()]);
  }
  /** 
 * Returns an instance of the given service. The first time this is
 * called for a given service, the BeanShell code is evaluated. The
 * result is cached for future invocations, so in effect services are
 * singletons.
 * @param clazz The service class
 * @param name The service name
 * @since jEdit 4.2pre1
 */
  public static Object getService(  String clazz,  String name){
    Descriptor key=new Descriptor(clazz,name);
    Descriptor value=(Descriptor)serviceMap.get(key);
    if (value == null) {
      return null;
    }
 else {
      if (value.code == null) {
        loadServices(value.plugin,value.plugin.getServicesURI(),null);
        value=(Descriptor)serviceMap.get(key);
      }
      return value.getInstance();
    }
  }
  /** 
 * Registers a service.
 * @since jEdit 4.2pre1
 */
  static void registerService(  Descriptor d){
    serviceMap.put(d,d);
  }
  private static Map serviceMap=new HashMap();
static class Descriptor {
    String clazz;
    String name;
    String code;
    PluginJAR plugin;
    Object instance;
    boolean instanceIsNull;
    Descriptor(    String clazz,    String name){
      this.clazz=clazz;
      this.name=name;
    }
    Descriptor(    String clazz,    String name,    String code,    PluginJAR plugin){
      this.clazz=clazz;
      this.name=name;
      this.code=code;
      this.plugin=plugin;
    }
    Object getInstance(){
      if (instanceIsNull)       return null;
 else       if (instance == null) {
        instance=BeanShell.eval(null,BeanShell.getNameSpace(),code);
        if (instance == null) {
          instanceIsNull=true;
        }
      }
      return instance;
    }
    public int hashCode(){
      return name.hashCode();
    }
    public boolean equals(    Object o){
      if (o instanceof Descriptor) {
        Descriptor d=(Descriptor)o;
        return d.clazz.equals(clazz) && d.name.equals(name);
      }
 else       return false;
    }
  }
}
---------------------------------------------------------------------------------------------------
static class RootsEntry extends VFS.DirectoryEntry {
  RootsEntry(  File file){
    this.path=this.deletePath=this.symlinkPath=file.getPath();
    if (isFloppy(file)) {
      type=VFS.DirectoryEntry.FILESYSTEM;
      name=path;
    }
 else     if (isDrive(file)) {
      type=VFS.DirectoryEntry.FILESYSTEM;
      if (getSystemDisplayName != null) {
        try {
          name=path + " " + (String)getSystemDisplayName.invoke(fsView,new Object[]{file});
        }
 catch (        Exception e) {
          Log.log(Log.ERROR,this,e);
          name=path;
        }
      }
    }
 else     if (file.isDirectory()) {
      type=VFS.DirectoryEntry.FILESYSTEM;
      if (isFileSystemRoot != null) {
        try {
          if (Boolean.FALSE.equals(isFileSystemRoot.invoke(fsView,new Object[]{file}))) {
            type=VFS.DirectoryEntry.DIRECTORY;
          }
        }
 catch (        Exception e) {
        }
      }
      if (OperatingSystem.isMacOS())       name=MiscUtilities.getFileName(path);
 else       name=path;
    }
 else     type=VFS.DirectoryEntry.FILE;
  }
  public String getExtendedAttribute(  String name){
    if (name.equals(EA_TYPE))     return super.getExtendedAttribute(name);
 else {
      return null;
    }
  }
  private boolean isFloppy(  File file){
    if (isFloppyDrive != null) {
      try {
        return Boolean.TRUE.equals(isFloppyDrive.invoke(fsView,new Object[]{file}));
      }
 catch (      Exception e) {
        Log.log(Log.ERROR,this,e);
        return false;
      }
    }
 else     return path.startsWith("A:") || path.startsWith("B:");
  }
  private boolean isDrive(  File file){
    if (isDrive != null) {
      try {
        return Boolean.TRUE.equals(isDrive.invoke(fsView,new Object[]{file}));
      }
 catch (      Exception e) {
        Log.log(Log.ERROR,this,e);
        return false;
      }
    }
 else     return true;
  }
}
---------------------------------------------------------------------------------------------------
/** 
 * Services work requests in the background.
 * @author Slava Pestov
 * @version $Id: logging.txt,v 1.1 2016/04/20 11:32:51 nziragch Exp $
 */
public class WorkThread extends Thread {
  public WorkThread(  WorkThreadPool pool,  ThreadGroup group,  String name){
    super(group,name);
    setPriority(Thread.MIN_PRIORITY);
    this.pool=pool;
  }
  /** 
 * Sets if the current request can be aborted.
 * @since jEdit 2.6pre1
 */
  public void setAbortable(  boolean abortable){
synchronized (abortLock) {
      this.abortable=abortable;
      if (aborted)       stop(new Abort());
    }
  }
  /** 
 * Returns if the work thread is currently running a request.
 */
  public boolean isRequestRunning(){
    return requestRunning;
  }
  /** 
 * Returns the status text.
 */
  public String getStatus(){
    return status;
  }
  /** 
 * Sets the status text.
 * @since jEdit 2.6pre1
 */
  public void setStatus(  String status){
    this.status=status;
    pool.fireProgressChanged(this);
  }
  /** 
 * Returns the progress value.
 */
  public int getProgressValue(){
    return progressValue;
  }
  /** 
 * Sets the progress value.
 * @since jEdit 2.6pre1
 */
  public void setProgressValue(  int progressValue){
    this.progressValue=progressValue;
    pool.fireProgressChanged(this);
  }
  /** 
 * Returns the progress maximum.
 */
  public int getProgressMaximum(){
    return progressMaximum;
  }
  /** 
 * Sets the maximum progress value.
 * @since jEdit 2.6pre1
 */
  public void setProgressMaximum(  int progressMaximum){
    this.progressMaximum=progressMaximum;
    pool.fireProgressChanged(this);
  }
  /** 
 * Aborts the currently running request, if allowed.
 * @since jEdit 2.6pre1
 */
  public void abortCurrentRequest(){
synchronized (abortLock) {
      if (abortable && !aborted)       stop(new Abort());
      aborted=true;
    }
  }
  public void run(){
    Log.log(Log.DEBUG,this,"Work request thread starting [" + getName() + "]");
    for (; ; ) {
      doRequests();
    }
  }
  private WorkThreadPool pool;
  private Object abortLock=new Object();
  private boolean requestRunning;
  private boolean abortable;
  private boolean aborted;
  private String status;
  private int progressValue;
  private int progressMaximum;
  private void doRequests(){
    WorkThreadPool.Request request;
    for (; ; ) {
      request=pool.getNextRequest();
      if (request == null)       break;
 else {
        requestRunning=true;
        pool.fireStatusChanged(this);
        doRequest(request);
        requestRunning=false;
      }
    }
    pool.fireStatusChanged(this);
synchronized (pool.waitForAllLock) {
      pool.waitForAllLock.notifyAll();
    }
synchronized (pool.lock) {
      try {
        pool.lock.wait();
      }
 catch (      InterruptedException ie) {
        Log.log(Log.ERROR,this,ie);
      }
    }
  }
  private void doRequest(  WorkThreadPool.Request request){
    Log.log(Log.DEBUG,WorkThread.class,"Running in work thread: " + request);
    try {
      request.run.run();
    }
 catch (    Abort a) {
      Log.log(Log.ERROR,WorkThread.class,"Unhandled abort");
    }
catch (    Throwable t) {
      Log.log(Log.ERROR,WorkThread.class,"Exception " + "in work thread:");
      Log.log(Log.ERROR,WorkThread.class,t);
    }
 finally {
synchronized (abortLock) {
        aborted=abortable=false;
      }
      status=null;
      progressValue=progressMaximum=0;
      pool.requestDone();
      pool.fireStatusChanged(this);
    }
  }
public static class Abort extends Error {
    public Abort(){
      super("Work request aborted");
    }
  }
}
