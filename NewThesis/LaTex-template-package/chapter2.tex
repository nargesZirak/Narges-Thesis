\chapter{Motivational Scenario}  \label{ch2}

Printing messages to the console or to a log file is an integral part of software development and can be used to test, debug, and understand what is happening inside an application. In Java programming language, \name{print} statements
are commonly used to print something on console. However, the availability of tools, frameworks, and APIs for logging that offers more powerful and advanced Java logging features, flexibility, and improvement in logging quality suggests that using \name{print} statements is not sufficient for real-world applications.


The logging framework offers many more features that are not possible using \name{print} statements. In most logging frameworks (e.g., \name{log4j}, \name{SLF4j}, \name{java.util.logging}), different verbosity levels of logging are available for use. That is, by logging at a particular log level, messages will get logged for that level and all levels above it and not for the levels below. As an example, \name{debug} log level messages can be used in a test environment, while \name{error} log level messages can be used in production environments. This feature not only produces fewer log messages, but also improves the performance of an application. In addition, most logging frameworks allow the production of formatted log messages, which makes it easier for a developer to monitor the behaviour of a system. Furthermore, when one is working on a server side application, the only way to know what is going on inside the server is by monitoring the log file. Although logging is a valuable practice for software development and maintenance, it imposes extra time and energy on developers to write, test, and run the code, while affecting the application performance. Since latency and speed are major concerns for most software systems, it is necessary  for a developer to understand and learn logging in great detail in order to perform it in an efficient manner.

To illustrate the inherent challenges of effectively performing logging practices in software systems, one may consider a scenario in which a developer is asked to log an event-based mechanism of a text editor tool written in the Java programming language. In this scenario, the developer is trying to log a Java class of this system (Figure~\ref{ch2-ex}) using the \name{log4j} logging framework. She knows that components of this application register with the \code{EditBus} class to receive messages that reflect changes in the application's state, and that the \code{EditBus} class maintains a list of components that have requested to receive messages. That is, when a message is sent using this class, all registered components receive it in turn. Furthermore, any classes that subscribe to the \code{EditBus} and implement the \code{EBComponent} interface define the method \code{EBComponent.handleMessage(EBMessage)} to handle a message sent on the \code{EditBus}. To perform this logging task, the developer might ask herself several fundamental questions, mostly related to where and what to log.

\begin{figure}[p]
\def\baselinestretch{1}
\begin{lstlisting}
public class EditBus {
    private static ArrayList components = new ArrayList();
    private static EBComponent[] copyComponents;
  
    private EditBus() {
    }
  
    public static void addToBus(EBComponent comp) {
        synchronized(components) {
            components.add(comp);
            copyComponents = null;
        }
    }

    public static void removeFromBus(EBComponent comp) {
        synchronized(components) {
            components.remove(comp);
            copyComponents = null;
        }
    }

    public static EBComponent[] getComponents() {
        synchronized(components) {
            if(copyComponents == null) {
                EBComponent[] arr = new EBComponent[components.size()];
                copyComponents = 
                    (EBComponent[])components.toArray(arr);
            }
        }
        return copyComponents;
    }
  
    public static void send(EBMessage message) {
        EBComponent[] comps = getComponents();
        for(int i = 0; i < comps.length; i++) {
            EBComponent comp = comps[i];
            long start = System.currentTimeMillis();
            comp.handleMessage(message);
            long time = (System.currentTimeMillis() - start);
        }
    }
}
\end{lstlisting}
\caption{The \code{EditBus} class.\label{ch2-ex}}
\end{figure}
%Developer's logging task context on

Her first solution might be to simply log at the start and end of every method. However, she believes that logging at the start and end of the \code{addToBus(EBComponent)}, \code{remove}\-\code{From}\-\code{Bus(EBComponent)}, and \code{getComponents()} methods are useless, and will produce redundant information. She assumes that the more she logs, the more she performs file I/O, which slows down the application. Therefore, she decides to log only important information necessary to debug or troubleshoot potential problems. She proceeds to identify the information needed to be logged and then decides on where to use logging calls. She thinks that it is important to log the information related to a message sent to a registered component, including the message content and the transmission time, to troubleshoot potential problems in sending messages. She simply wants to begin by using a logging call at the start of the \code{send()} method (line~2 of Figure~\ref{ch2-ex-logged-m1}) to log the information. However, she realizes that this logging call does not allow her to log the information she wants, as the \code{time} variable is not initialized at the beginning of this method. Therefore, she proceeds to examine the body of the \code{send()} method line-by-line and uses another logging call after the \code{time} variable is initialized inside an \code{if} statement that checks that the value of the variable \code{time} is not invalid (shown in lines~9--11 of Figure~\ref{ch2-ex-logged-m2}).

\begin{figure}[p]
\def\baselinestretch{1}
\begin{lstlisting}
public static void send(EBMessage message){
   //logging call
   EBComponent[] comps = getComponents();
   for (int i = 0; i < comps.length; i++) {
       EBComponent comp = comps[i];
       long start = System.currentTimeMillis();
       comp.handleMessage(message);
       long time = (System.currentTimeMillis() - start);
   }
}
\end{lstlisting}
\caption{The developer's initial determination of the usage of logging calls for the \code{send(EBMessage)} method.\label{ch2-ex-logged-m1}}
\end{figure}

\begin{figure}[p]
\def\baselinestretch{1}
\begin{lstlisting}
public static void send(EBMessage message) {
    // logging call
    EBComponent[] comps = getComponents();
    for(int i = 0; i < comps.length; i++) {
        EBComponent comp = comps[i];
        long start = System.currentTimeMillis();
        comp.handleMessage(message);
        long time = (System.currentTimeMillis() - start);
        if(time != 0){
            // logging call
        }
    }
}
\end{lstlisting}
\caption{The developer's second determination of the usage of logging calls for the \code{send(EBMessage)} method.\label{ch2-ex-logged-m2}}
\end{figure}

\begin{figure}[p]
\def\baselinestretch{1}
\begin{lstlisting}
public static void send(EBMessage message){
    try {
        // logging call
        EBComponent[] comps = getComponents();
        for(int i = 0; i < comps.length; i++) {
            EBComponent comp = comps[i];
            long start = System.currentTimeMillis();
            comp.handleMessage(message);
            long time = (System.currentTimeMillis() - start);
            if(time != 0){
                // logging call
            }
        }
    } catch(Throwable t) {
       // logging call
    }
}
\end{lstlisting}
\caption{The developer's third determination of the usage of logging calls for the \code{send(EBMessage)} method.\label{ch2-ex-logged-m3}}
\end{figure}

She also believes that it is important to log an error if any problems occur in sending messages to the components. She decides to use a \code{try}/\code{catch} statement, as it is a common way to handle exceptions in the Java programming language. She creates a \code{try}/\code{catch} block to capture the potential failure in sending messages, and uses a logging call inside the \code{catch} block to log the exception (shown in lines~2--16 of Figure~\ref{ch2-ex-logged-m3}). However, she realizes that using this logging call will not allow her to reach the desired functionality, as it does not reveal to which component the problem is related. Thus, she decides to relocate the \code{try}/\code{catch} block inside the \code{for} statement to log an error in case of a problem in sending messages to any components (shown in lines~5--15 of Figure~\ref{ch2-ex-logged-m4}).


\begin{figure}[p]
\def\baselinestretch{1}
\begin{lstlisting}
public static void send(EBMessage message) {
    // logging call
    EBComponent[] comps = getComponents();
    for (int i = 0; i < comps.length; i++) {
        try {
            EBComponent comp = comps[i];
            long start = System.currentTimeMillis();
            comp.handleMessage(message);
            long time = (System.currentTimeMillis() - start);
            if(time != 0) {
                // logging call
            }
        } catch(Throwable t) {
            // logging call
        }
    }
}
\end{lstlisting}
\caption{The developer's fourth determination of the usage of logging calls for the \code{send(EBMessage)} method.\label{ch2-ex-logged-m4}}
\end{figure}

\begin{figure}[p]
\def\baselinestretch{0.94}
\begin{lstlisting}
public class EditBus {
    private static ArrayList components = new ArrayList();
    private static EBComponent[] copyComponents;

    private EditBus() {
    }

    public static void addToBus(EBComponent comp) {
        synchronized(components) {
            components.add(comp);
            copyComponents = null;
        }
    }
  
    public static void removeFromBus(EBComponent comp) {
        synchronized(components) {
            components.remove(comp);
            copyComponents = null;
        }
    }

    public static EBComponent[] getComponents() {
        synchronized(components) {
            if(copyComponents == null) {
                EBComponent[] arr = new EBComponent[components.size()];
                copyComponents = (EBComponent[])components.toArray(arr);
            }
        }
        return copyComponents;
    }
  
    public static void send(EBMessage message) {
        // logging call
        EBComponent[] comps = getComponents();
        for(int i = 0; i < comps.length; i++) {
            try {
                EBComponent comp = comps[i];
                long start = System.currentTimeMillis();
                comp.handleMessage(message);
                long time = (System.currentTimeMillis() - start);
                if(time != 0) {
                    // logging call
                }
            } catch(Throwable t) {
                // logging call
            }
        }
    }
}
\end{lstlisting}
\caption{The developer's final determination of the usage of logging calls for the \code{EditBus} class.\label{ch2-ex-logged}}
\end{figure}

Figure~\ref{ch2-ex-logged} shows the developer's final determination to use logging calls to perform the logging task of the \code{EditBus} class. By making appropriate decisions about where to use logging calls, the developer is in a good position to proceed to write the logging messages by examining the remaining conceptually complex questions. Which information should I log? How should I choose the log message format? Which information goes to which level of logging? If the developer had reached this point more easily and quickly, she would have had more time and energy to make decisions about the remaining issues and could have completed the logging practice in a timely and appropriate manner.

%\RW{This is followed by a summary, so it is rather redundant.}
%To sum up, this scenario required the developer to make numerous decisions and then act on them. Her attention was split between detailed and the high-level decisions. In addition, time constraints and the performance of tedious tasks can cause the developer to make bad decisions. However, having a vision of where developers usually use logging calls in similar situations could guide her to make informed decisions about where to use logging calls, and she could then perform the logging task in a faster and less error-prone manner.


\section{Summary}  \label{ch2-summary}

This motivational scenario highlights the problems a developer may encounter in performing a logging task.
The core problem she faces in this scenario is the difficulty in understanding where to use logging calls that enable her to log the desired information. However, having an understanding of how developers usually log in similar situations might assist her to make informed decisions about where to use logging calls more quickly, and so she could pay more attention to the remaining, conceptually complex issues to complete the logging task.




