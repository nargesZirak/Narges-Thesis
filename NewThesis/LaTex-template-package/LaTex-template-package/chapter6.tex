\chapter{Discussion}  \label{diss}

In this chapter, we discuss the validity of our evaluation and the characterization study (Section~\ref{threads}), the limitations and pitfalls of the approach and our tool support (Section~\ref{limitations}), and a number of remaining issues including: the other applications of our tools' underlying framework (Section~\ref{other_applications}); the usage of anti-unification theory (Section~\ref{auTheory}).

\section{Threats to validity}  \label{threads}
Prior to applying our tool for characterizing logging usage in real-world software systems, we have conducted three experiments to investigate the effectiveness of our proposed approach. However, there are several potential threats regarding the validity of these experiments. First, the results of our manual examination might be biased, as I determined the correct correspondences between ASTs and the correct way of classifying the set of ASTs in our test suite based on a similarity measurement. To limit the bias, other people can be involved to double check the accuracy of my manual inspection in a future work. Secondly, the experiments have examined one test suite containing a set of LJMs from a real-world software system, though different test suites may generate different results. Although I cannot claim that the LJMs in my test suite are a good representative of all LJMs in real-world software systems, the results are still promising, as logging calls are used in various ways in Java methods of my test suite, and have sufficed to indicate the effectiveness of my approach in constructing structural generalizations. Another potential thread is that the successful rate of detecting correspondences by our tool might happen accidentally only for our test suite. To resolve this doubt, we examined the cases where our tool fails to detect correct correspondences and we found that the failures are due to the fundamental limitations and complexities in the construction of structural generalization through the use of structural correspondence. That is, our tool creates structural generalizations successfully with regard to what our algorithm should generate.
%, and the assumptions taken in developing the algorithms.
%CITATION POPULARITY!!!
%There are several threats to the validity of our characterization study.
A potential thread to the validity of our characterization study is the degree to which our sample set of software systems is a good representation of all real-world logging usage. To address this issue, we selected various open-source software projects in terms of application, including a programming text editor, a web server, and an application server. These software systems are among the most popular applications in their own product category, and they all have at least 10 years of history in software development. However, our findings might not be able to reflect the characteristics of logging usage in other types of systems such as commercial software, or software written in other programming languages. 
%citation???
%application of softwares???

\section{Our tool output}  \label{limitations}
In addition, there are some issues that the approximation approach and our tool support is not able to handle perfectly, including node ordering mismatch, and the management of conflicts happened in constructing the anti-unifiers.

\subsection{Node ordering mismatch}  \label{mismatch} 
Our anti-unification algorithm does not guarantee to maintain the correct sequence of statements in the body of methods when anti-unifying two method declaration nodes, since the order of statement nodes is not considered in determining the best correspondences. For example, consider we have two corresponding methods $\id{method_1}$ and $\id{method_2}$ embodying {$\id{a_1}$, $\id{a_2}$, $\id{a_3}$} and {$\id{b_1}$, $\id{b_2}$} sequences of statements, respectively. If our tool finds that the $\id{b_1}$ and $\id{b_2}$ nodes are the best correspondences for the $\id{a_3}$ and $\id{a_1}$ nodes respectively, the output generalization view for the set of statement nodes would be {$\id{a_1}$-or-$\id{b_2}$, $\id{a_2}$-or-$\NIL{}$, $\id{a_3}$-or-$\id{b_1}$}. Therefore, the generalization view does not preserve the correct ordering of nodes in the original structures.


\subsection{handle conflicts in constructing the anti-unifiers}  \label{conflicts} 
The decisions we have made to resolve the conflicts occurred in constructing structural generalizations might affect the accuracy of our results.
For example, in situations where we have two correspondences with the same similarity value in the ordered list of correspondence connections, our approach picks the one which involves two subtrees with higher number of leaves, though it might be not the best choice for all cases. 
In addition, we consider AST hierarchies to perform anti-unification. That is, our algorithm does not anti-unify two nodes if their parent nodes are not found to be corresponded. As a result, situations can occur where in fact two nodes should be anti-unified with each other, while they are not anti-unified by the tool. Though these decisions leads us to get approximate results, they helped to limit the complexity of our approach allowing the implementation of it as a practical solution.

 % add semantic to structural information to detect correspondences?? 
%limited typing information to determine correspondences by %Jigsaw
%\item Our tool does not guarantee the correctness of determining the best correspondences due to
%\begin{itemize} [leftmargin=.3in]
%\item the various conflicts that happen
%\item limited typing information to determine correspondences by %Jigsaw
%\end{itemize}
%\item Structural generalizations constructed by our tool are not in %the form of executable code
%[leftmargin=.3in]\end{itemize}


\section{Other applications}  \label{other_applications}
Any applications that are involved in the inference of structural patterns in source code even infrequently-used patterns might benefit from our tool’s underlying framework.
%% EXAMPLE??? 
Furthermore, understanding the commonalities and differences between source code fragments has application in several areas of software engineering, such as code clone detection, API usage pattern collation, recommending replacements for API migration, and merging different branches of version control systems. Our tool`s functionality to construct a detailed view of structural generalizations to represent the similarities and differences between a set of source code fragments via structural correspondence could be used to improve the results of these studies as well.
%edit!!!
\section{Applications of anti-Unification}  \label{auTheory}
Our study demonstrates the application of an extended from of anti-unification (HOAUMT) to infer usage patters of log statements in source code via the creation of structural generalizations. Anti-unification and its extensions have been already applied to solve several theoretical and practical problems, such as analogy making [Schmidt, 2010], determining lemma generation in equational inductive proofs [Burghardt, 2005], and detecting the construction laws for a sequence of structures [Burghardt, 2005]. 
%CITATION??

Higher-order anti-unification modulo theories can be used to create generalizations in different contexts, and therefore the set of equational theories should be developed particularly for the higher-order structure used in each problem context. That is, the utility of these theories are highly dependent on how well they allow the incorporation of semantic knowledge of structures. In addition, these theories should ensure that only a finite number of anti-instances exist for each structure. Taking all these considerations into account enables HOAUMT to anti-unify sets of structures, which is useful for a particular context. The practical tests I have conducted through the application of my tool on a test suite demonstrate that our approximation of HOAUMT was successful in constructing structural generalizations required to solve our problem.
%

%?????????
The problem of my study is different, but this work shows how the Jigsaw framework could be useful in constructing structural generalizations to solve a particular problem context via the determination of structural correspondences between two ASTs. The application of HOAUMT to construct structural generalizations via structural correspondences is novel to the problem of extracting usage patterns of log statements in source code.
Finally, we made a comparison between our tool and the Jigsaw tool, which were developed for various applications, but part of the implementation of Jigsaw was successfully applied to solve our problem context.



\section{Summary}  \label{diss-summary}
We discussed the potential threads to validity of our evaluation and characterization study. To limit the bias of the experiments we conducted to evaluate the effectiveness of our approach and the tool support, we selected our test cases form a real system with various levels of similarity in the usage of logging calls. Furthermore, we examined the failed test cases to assure that our tool works when it should work with regard to the proposed algorithm. We will also make our test suite available for public examination to check the accuracy of our manual inspection. For our characterization study, we selected various software systems in terms of functionality that are widely used by many developers for a long period of time. We also discussed the remaining issues with our tool support including node ordering, …, and … that can be resolved in future as the extensions of our work.

This work aim to provide a detailed view of structural generalizations constructed from a set of source code fragments that use log statements via structural correspondence and clustering. However, we discussed that any other applications involved in the inference of structural usage patterns of a particular statement or the detection of commonalities and differences between a set of source code fragments could benefit from our tool’s underlying framework.

We also argued how higher-order anti-unification modulo theories can be effectively approximated for various applications by means of developing an appropriate set of equational theories particularly for the higher-order structure used in each problem context. 
