\chapter{Characterization Study}\label{discover}\label{eval}

To characterize the location of log statements in source code, I conducted an experimental study that addresses the following research questions: 

\begin{itemize} [leftmargin=.5in]
\item \textsc{RQ1: }\emph{``Is it possible to find patterns of where log statements occur in source code?''} I aim to investigate whether there are clusters containing a large number of LMs. This suggests that there might be common ways of locating log statements in source code.

\item \textsc{RQ2: }\emph{``What common structural characteristics do logged methods have?''} I conducted a manual analysis on the detailed view of structural generalizations produced by \tool{ELUS} to identify the common structural characteristics of LMs in each cluster.
\end{itemize}


\section{Experiment}  \label{setup-characterization}
%\subsection{Setup}  \label{setup}
In this experiment, I will analyze logging usage of five popular open-source software systems: \name{Apache Tomcat}, \name{Hibernate ORM}, \code{Apache Camel}, \name{Apache Solr}, and \name{...}. Each system is written in the Java programming language and they all utilize the same logging framework, \name{Apache Log4j}. I decided to study the usage of \name{log4j} statements in these systems, as \name{Apache Log4j} is ranked as the most commonly used logging package for Java\footnote{\url{https://en.wikipedia.org/wiki/Java_logging_framework}}. The studied systems are from different application domains: \code{Apache Tomcat} is a Java Servlet; \code{Hibernate ORM} is a object relational-mapping framework; \code{Apache Camel} is a rule-based routing and mediation engine; and \name{Apache Solr} is an enterprise search platform. I chose these systems as my study subject due to their popularity in their area of application (7000+ commits to the \name{GitHUb} repository) and long history of development (9 to 13 years). Table~\ref{table:ljms} represents the details about these software systems. I also decided to exclude the \name{log4j} statements at the \name{trace-} and \name{debug-} verbosity level, as they are usually used by developers only during the software development phase. I believe that studying these systems could give us an insight about logging usage in real-world applications.


%I only examined the log statements from the \name{Apache Log4j} framework, and 


\begin{figure} [H]
  \centering
  \begin{tabular}{llcccc}
    \toprule
    \textbf{Software system}  & \textbf{Description}   & \textbf{Version} & \textbf{Start time} & \textbf{LOC} & \textbf{Log statements} \\ \hline
    {Tomcat} & Server  & 9.0.11& 2003 &306,704 &  3,117 \\ \hline
{Hibernate ORM} & Framework & 4.2.23 & 2004 & 509,734 & 1,939 \\ \hline
    {Camel} &  Middleware & 2.18.0 &  2007 &120,528 & 2,177 \\
    \hline
    {Solr} &  Platform  & 6.2.1 &  2007 & 128,824 & 2,319 \\
%{OpenMeetings} & Web Conferencing & & 2.0 &38K &3506 \\ \hline
 %   {QuickFIX/J} & Engine & 1.6 & 48K & 2958 \\
   % \bottomrule
    \toprule
  \end{tabular}
   %\caption{Details of the five open-source software systems that make use of the {Apache Log4j} logging framework.}
    \caption{Summary of the five software systems used in the characterization study.}
\label{table:ljms}
\end{figure}


My proof-of-concept implementation takes the source code of these systems as input, extracts the ASTs of their LMs, applies the proposed algorithm to construct AUASTs, classifies the AUASTs into clusters, and outputs the detailed view of structural generalization (LUS) for each cluster.
%, called LUS.


\subsection{Results}  \label{results-characterization}
The experimental results for each software system are presented in Table~\ref{tab_results_1}. This table describes the total number of detected \name{log4j} statements (debug- and trace-level log statements are excluded), the number of logged methods (LMs); the number of generated clusters; the number of generalized clusters containing more than one LM; the number of singleton clusters that only contain one LM; and the reduction percentage calculated by the Equation~\ref{reduction_eq}. In addition, Figure~\ref{fig:histograms} shows the histograms of the number of LMs per cluster for each system.




\begin{equation}\label{reduction_eq}
\id{reduction} = \frac{|\id{Primitive~clusters}| - |\id{Clusters}|}{|\id{Primitive~clusters}|}
\end{equation}
 

\begin{table}[h]
\vspace*{1em}
\let\A\relax
\newlength{\A} \settowidth{\A}{288}
\let\B\relax
\newlength{\B}
\settowidth{\B}{288}
\let\Cl\relax
\newlength{\Cl}
\settowidth{\Cl}{288}
\let\Ac\relax
\newlength{\Ac}
\settowidth{\Ac}{}
\let\Bc\relax
\newlength{\Bc}
\settowidth{\Bc}{}
\let\Abc\relax
\newlength{\Abc}
\settowidth{\Abc}{}
\let\Pwa\relax
\newlength{\Pwa}
\settowidth{\Pwa}{\%}
\centering\begin{tabular}{lccccc}
  \toprule 
   & \multicolumn{1}{c}{Tomcat}  & \multicolumn{1}{c}{Hibernate} & \multicolumn{1}{c}{Camel}  & \multicolumn{1}{c}{Solr} & \multicolumn{1}{c}{}\\
  \midrule
  Log4j statements          & \makebox[\Ac][c]{1098}                                  & \makebox[\Bc][c]{128}  & \makebox[\Abc][c]{632}  & \makebox[\Abc][c]{1484} \\
 LMs               & \makebox[\Ac][c]{658}                                  & \makebox[\Bc][c]{81}     & \makebox[\Abc][c]{490}& \makebox[\Abc][c]{818}
\\\midrule

 Primitive clusters  & \makebox[\Ac][c]{\makebox[\A][r]{1098}}                 & \makebox[\Bc][c]{\makebox[\B][r]{128}}                 & \makebox[\Abc][c]{\makebox[\Cl][r]{632}}  & \makebox[\Abc][c]{\makebox[\Cl][r]{1484}}  \\

 Clusters  & \makebox[\Ac][c]{\makebox[\A][r]{43}}                 & \makebox[\Bc][c]{\makebox[\B][r]{12}}                 & \makebox[\Abc][c]{\makebox[\Cl][r]{49}} & \makebox[\Abc][c]{\makebox[\Cl][r]{50}}\\


  Generalized clusters  & \makebox[\Ac][c]{\makebox[\A][r]{20}}                 & \makebox[\Bc][c]{\makebox[\B][r]{9}}                 & \makebox[\Abc][c]{\makebox[\Cl][r]{18}}  & \makebox[\Abc][c]{\makebox[\Cl][r]{27}} \\


  Singleton clusters       & \makebox[\Ac][c]{\makebox[\A][r]{23}}                 & \makebox[\Bc][c]{\makebox[\B][r]{3}}                 & \makebox[\Abc][c]{\makebox[\Cl][r]{31}} & \makebox[\Abc][c]{\makebox[\Cl][r]{23}} \\\midrule

  Reduction                       & \makebox[\Ac][c]{\makebox[\A][r]{96\%\hspace*{-\Pwa}}} & \makebox[\Bc][c]{\makebox[\B][r]{91\%\hspace*{-\Pwa}}} &\makebox[\Bc][c]{\makebox[\B][r]{92\%\hspace*{-\Pwa}}}&\makebox[\Bc][c]{\makebox[\B][r]{96\%\hspace*{-\Pwa}}}\\
 
    
  \toprule 
\end{tabular}
%\caption{Within-version experiment.}
\caption{The experimental results.}
%\caption{Experimental results for the the software systems}
\label{tab_results_1} \vspace*{1em}
\end{table}
%[width = 1\textwidth, height = 0.4\textheight]

\begin{figure} [H]
  \centering\includegraphics [width = 1\textwidth]{Charts/Histograms.png}
  \caption{Histograms of the number of LMS per cluster.}
  \label{fig:histograms}
\end{figure}


\subsection{Analysis}  \label{analysis}
The first research question is : \emph{"Is it possible to find patterns of where log statements occur in source code?"}. As it is shown in Table~\ref{tab_results_1}, the number of clusters has been reduced by more than 90\% in all the studied systems, indicating that developers follow some patterns for locating the log statements in source code. Furthermore, histograms depicted in Figure~\ref{fig:histograms} show that in all the studied systems, a few clusters contain a large number of LMs; however, the other clusters contain a very few number of LMs (only one or two). This indicates that in these cases developers follow a more complex or rare way of locating log statements. 

The second research question is : \emph{``What common structural characteristics do logged methods have?''}
To address this question, I have manually went through the LUSs of anti-unifiers to identify the common structural characteristics of locating the log statements in source code. 

%a few rare exception
%ADD-> THE USEAGE WITH AN EXCEPTION
  
\subsubsection{\emph{Categorizing logging usage}}
In this section, I will describe the anti-unifiers of logging usage by examining the LUSs produced by \tool{ELUS}. In general, there are six categories of anti-unifiers in the logging usage. In the following sections, I will describe the common structural characteristics of each category represented by the anti-unifiers. In addition, Figure~\ref{fig:categories} presents the number of LMs in each category and its percentage to the total number of LMs for each of the software systems. 

\begin{figure} [H]
  \centering\includegraphics [width = 1\textwidth]{Charts/Categories.png}
  \caption{The distribution of the categories of anti-unifiers in the logging usage.}
  \label{fig:categories}
\end{figure}


\subsubsection{\emph{A. Exception Catch-block Logging}}  \label{Exception catch-block logging}
The main common structural characteristics of the anti-unifiers of this category are the \code{try} and \code{catch} \code{statements}, where the \code{log statements} are located inside the body of a \code{Catch Clause}. As shown in Figure~\ref{fig:categories}, 14\% to 53\% of the total LMs are described by the anti-unifiers of this category, and it is the most commonly used logging usage category in the \name{Tomcat} and \name{Hibernate} software systems. The popularity of this category among all the studied systems is due to the fact that exception handling using the \code{try}/\code{catch} blocks is a common error handling technique in the Java programming language.

%a large portion of LMs are described by the anti-unifiers of this category.

\subsubsection{\emph{B. Conditional Logging}}  \label{conditional logging}
In this category, \code{log statements} are enclosed by \code{if} statements that their expressions are mostly among \code{Infix} \code{Expression}, \code{Method} \code{Invocation}, or \code{Binary} \code{Expression} nodes. The \code{Infix} \code{Expressions} mostly check if the value of a variable either equals to the \code{Null} \code{Literal} or is outside of a valid range; the \code{if} \code{statements} with \code{Method} \code{Invocations} mostly check if the return value of an invoked method is an indicator of a potential problem within the system; and the \code{if} \code{statements} with \code{Binary Expressions} mostly checks if a \code{Boolean} \code{Literal} is incorrect. As shown in Figure~\ref{fig:categories}, 17\% to 36\% of the total LMs are described by the anti-unifiers of this category, and it is the most commonly used logging category in the \name{Solr} system.

\subsubsection{\emph{C. Method Logging}}  \label{method logging}
In this category, the \code{log statements} are located inside the body of \code{Method Declaration} nodes. A common structural characteristic of the anti-unifiers in this category is that they mostly use the \code{Throw Statements} to throw an exception if an error occurs. The percentage of LMs that are described by the anti-unifiers of this category ranges from 3\% to 51\%, and it is the most common logging usage category in the \name{Apache Camel}. This suggests that developers use logging to record important method granularity information about the state of a software system. This information might be used later to  detect the root causes of an application problem.
% %?
% throw exception

\subsubsection{\emph{D. Exception Try-block Logging}}  \label{Exception try-block logging}
In this category, the \code{log statement} is located inside the body of the \code{try} \code{statement} of a \code{try}/\code{catch} block. These \code{log statements} can be used to record important information about the code that may throw an exception. According to the Figure~\ref{fig:categories}, 1\% to 16\% of the total LMs of the studied systems are described by the anti-unifiers of this category. 


\subsubsection{\emph{E. Control Flow Logging}}  \label{Exception try-block logging}
In this category, the \code{log statements} are located inside the body of either \code{switch-} or \code{if-then-else-} statements. These \code{log statements} can be used to reveal necessary information to track the location of root causes of a potential problem in a software system. According to the Figure~\ref{fig:categories}, 0\% to 6\% of the total LMs are described by the anti-unifiers of this category.


\subsubsection{\emph{F. Loop Control Logging}}  \label{loop control logging}
The \code{log statements} of this category are located inside the \code{for-}, \code{enhanced-for-}, \code{while-}, or \code{do-while-} statements. These \code{log statements} are mostly used to log important information about every object of a Java \code{Collection}. This information might be helpful to diagnose the root causes of a failure within a system. According to the Figure~\ref{fig:categories}, a low percentage of LMs (1\% to 3\%) are described by the anti-unifiers of this category. This suggest that in practice, it is not a common way of using \code{log statements} in source code.  

% an example of an exception
% usage ---> change the location of exception to fit to one of these categories ---> improv the quality of logging practice

\section{Evaluation}  \label{evaluation}
An empirical study is conducted to evaluate the quality of the anti-unifiers generated by \code{ELUS} in describing the location of log statements in source code. Section~\ref{precision} describe the process of evaluating the precision and recall of \tool{ELUS}.


\subsubsection{\emph{Calculating the precision and recall}}  \label{precision}
To find the locations in source code that are described by an anti-unifier using \tool{ELUS}, I applied the \func{Determine-Locations} algorithm, which takes the anti-unifier and a list of all methods in source code and outputs a list of methods that their AUAST matches the anti-unifier AUAST. This algorithm anti-unifies each method in the list with the anti-unifier using the \func{Antiunify} algorithm described in Section~\label{meth-antiUnifier}(Lines~2--3). If the result equals the anti-unifier, that method will be added to the list of locations matching the anti-unifier (Lines~4--5). \func{Equals} is a procedure that takes two AUAST nodes and checks whether they are equal or not. To evaluate the generalizability of the anti-unifiers, I have implemented this procedure in two ways: (1) when variables are considered to be \emph{constrained}, it tests that the non-variable nodes are identical in the two AUASTs and checks if the constraints of variable are identical or not. (2) When variables are considered to be \emph{unconstrained}, it tests that the non-variable nodes are identical in the two AUASTs, but permits unconstrained variables to differ. I ran my tool on the source code of the five studied systems and applied this algorithm to find the locations in the code that matches the structure of the generated anti-unifiers. Then, the precision and recall metrics are calculated using the equations~\ref{precision_eq} and~\ref{recall_eq}, respectively.


\begin{algorithm}
\caption{\func{Determine-Locations}($\id{antiUnifier}$,$\id{methods}$) finds the locations in source code that matches an anti-unifier.}
\label{alg-determine}
\begin{algorithmic}[1]
\DetermineLocations
    \State $\id{locations} \gets \func{()}$
    \For {$\id{method} \in \id{methods}$}
    \State $\id{result} \gets  \func{AntiUnify}(\id{antiUnfier},\id{method})$
		\If {$\func{Equals}(\id{result},\id{antiUnifier})$ }	
				 	\State{$\func{Append}(\id{method},\id{locations})$ }
		\EndIf 		
		\EndFor
 \Return $\id{locations} $  	
  \end{algorithmic}
\end{algorithm}

\begin{equation}\label{precision_eq}
\id{precision} = \frac{\id{TP}}{{\id{TP}+\id{FP}}}
\end{equation}
 

\begin{equation}\label{recall_eq}
\id{recall} = \frac{\id{TP}}{{\id{TP}+\id{FN}}}
\end{equation}
 

Where TP is the number of correct locations obtained, FP is the number of incorrect locations retrieved, and FN is the number of correct locations that are not retrieved. Figures~\ref{fig:precision} and \ref{fig:recall} show the precision and recall results for each software system where the experiment was run once with constrained variables and once with unconstrained variables.


\begin{figure} [H]
  \centering\includegraphics [width = 0.7\textwidth, height = 0.3\textheight]{Charts/Precision.png}
  \caption{The precision of \tool{ELUS}.}
  \label{fig:precision} 
\end{figure}

\begin{figure} [H]
  \centering\includegraphics [width = 0.7\textwidth, height = 0.3\textheight]{Charts/Recall.png}
  \caption{The recall of \tool{ELUS}.}
  \label{fig:recall} 
\end{figure}

\subsubsection{\emph{Precision Results}}  \label{precision-results}
The green and yellow bars in Figure~\ref{fig:precision}  show the precision results when the experiment was run with constrained and unconstrained variables, respectively. I have also calculated the overall average precision of \tool{ELUS}, by averaging the precision values between the five software systems. The average precision for \tool{ELUS} is 88\% and 38\% for constrained and unconstrained variable experiments, respectively. In general, the precision for constrained variables are fairly high. The main reason behind the high precision is that in these cases the variables can only be substituted with some particular nodes, which makes the anti-unifier very specific. Furthermore, according to the Figure~\ref{fig:precision}, the precision is fairly low for unconstrained variables. The main reason for the low precision for these cases is the fact that the unconstrained variables can be substituted by any nodes, which makes the anti-unifiers too general. As a result, the tool finds many incorrect locations the matches the anti-unifiers. 
 
\subsubsection{\emph{Recall Results}}  \label{recall-results}
The green and yellow bars in Figure~\ref{fig:recall}  show the recall results when the experiment was run with constrained and unconstrained variables, respectively. I have also calculated the overall average recall of \tool{ELUS}, by averaging the recall values between the studied systems. The average recall for \tool{ELUS} is 80\% and 92\% for the constrained and unconstrained variable experiments, respectively. In general, when variables are constrained, \tool{ELUS} can detect many correct locations, as the recalls for all the studied systems are fairly high. Also, \tool{ELUS} can detect most of the correct locations in source code when no constraints are taken on variable nodes. 

The main reason behind \tool{ELUS}`s failure in detecting the correct locations is the potential complexities in constructing anti-unifiers from a large set of source code fragments. As in some cases, the anti-unifier might not maintain the correct locations of nodes in the AST hierarchy, and thus \tool{ELUS} would not be able to detect correct locations of log statements in the source code.  


%ADDDDD
% assess the generalizability of the anti-unifiers --> in between 
%In general,  the tool retrieved some locations matching the anti-unifiers, while in fact they do not match. 
%the tool failed to retrieve the correct locations, and in other cases


\section{Summary}
I conducted an experimental study to characterize the location of log statements by applying my tool on the source code of five full software systems that make use of the \code{Apache Log4j} logging framework. My tool inputs the source code of these systems, extracts ASTs of LMs, applies the proposed anti-unification and clustering algorithms, and outputs the anti-unifier for each cluster. I also conducted an experimental study to evaluate the precision and the recall of \tool{ELUS} in constructing the anti-unifiers that describe the location of log statements in source code. This experiment shows that \tool{ELUS} has achieved promising results in terms of precision and recall. Furthermore, The results taken from the characterization experiment shows that there are common ways of locating log statements I manually examined the detailed view of structural generalizations to categorize the anti-unifiers of logging usage.


% In summary, this experiment shows that \tool{ELUS} has achieved promising results in terms of precision and recall metrics.

% My analysis has resulted in ... different anti-unifiers in the logging usage. 

% figure out the common structural characteristics of LMs in each cluster. 
%I found out that most log statements are embedded inside ....
