\chapter{Characterization Study}\label{discover}\label{eval}

To characterize the location of log statements in source code, I conducted an experimental study that addresses the following research questions:

\begin{itemize} [leftmargin=.5in]
\item \textsc{RQ1: }\emph{``Is it possible to find patterns of where log statements occur in source code?''} I aim to investigate whether there are clusters containing a large number of LMs. This suggests that there might be common ways of locating log statements in source code.

\item \textsc{RQ2: }\emph{``What common structural characteristics do logged methods have?''} I conducted a manual analysis on the detailed view of structural generalizations produced by \tool{ELUS} to identify the common structural characteristics of LMs in each cluster.
\end{itemize}


\section{Experiment}  \label{setup-characterization}
%\subsection{Setup}  \label{setup}
In this experiment, I will analyze logging usage of four popular open-source software systems: \name{Apache Tomcat}, \name{Hibernate ORM}, \code{Apache Camel}, and \name{Apache Solr}. Each system is written in the Java programming language and they all utilize the same logging framework, \name{Apache Log4j}. I decided to study the usage of \name{log4j} statements in these systems, as \name{Apache Log4j} is ranked as the most commonly used logging package for Java\footnote{\url{https://en.wikipedia.org/wiki/Java_logging_framework}}. The studied systems are from different application domains: \code{Apache Tomcat} is a Java Servlet; \code{Hibernate ORM} is a object relational-mapping framework; \code{Apache Camel} is a rule-based routing and mediation engine; and \name{Apache Solr} is an enterprise search platform. I chose these systems as my study subject due to their popularity in their area of application (7000+ commits to the \name{GitHUb} repository) and long history of development (9 to 13 years). Table~\ref{table:ljms} represents the details about these software systems. I also decided to exclude the \name{log4j} statements at the \name{trace-} and \name{debug-} verbosity level, as they are usually used by developers only during the software development phase. I believe that studying these systems could give us an insight about logging usage in real-world applications.


%I only examined the log statements from the \name{Apache Log4j} framework, and


\begin{figure} [H]
  \centering
  \begin{tabular}{llcccc}
    \toprule
    \textbf{Software system}  & \textbf{Description}   & \textbf{Version} & \textbf{Start time} & \textbf{LOC} & \textbf{Log statements} \\ \hline
    {Tomcat} & Server  & 9.0.11& 2003 &306,704 &  3,117 \\ \hline
{Hibernate ORM} & Framework & 4.2.23 & 2004 & 509,734 & 1,939 \\ \hline
    {Camel} &  Middleware & 2.18.0 &  2007 &120,528 & 2,177 \\
    \hline
    {Solr} &  Platform  & 6.2.1 &  2007 & 128,824 & 2,319 \\
%{OpenMeetings} & Web Conferencing & & 2.0 &38K &3506 \\ \hline
 %   {QuickFIX/J} & Engine & 1.6 & 48K & 2958 \\
   % \bottomrule
    \toprule
  \end{tabular}
   %\caption{Details of the four open-source software systems that make use of the {Apache Log4j} logging framework.}
    \caption{Summary of the four software systems used in the characterization study.}
\label{table:ljms}
\end{figure}


My proof-of-concept implementation takes the source code of these systems as input, extracts the ASTs of their LMs, applies the proposed algorithm to construct AUASTs, classifies the AUASTs into clusters, and outputs the detailed view of structural generalization (LUS) for each cluster.
%, called LUS.


\subsection{Results}  \label{results-characterization}
The experimental results for each software system are presented in Table~\ref{tab_results_1}. This table describes the total number of detected \name{log4j} statements (debug- and trace-level log statements are excluded), the number of logged methods (LMs); the number of generated clusters; the number of generalized clusters containing more than one LM; the number of singleton clusters that only contain one LM; and the reduction percentage calculated by the Equation~\ref{reduction_eq}. In addition, Figure~\ref{fig:histograms} shows the histograms of the number of LMs per cluster for each system.




\begin{equation}\label{reduction_eq}
\id{reduction} = \frac{|\id{Primitive~clusters}| - |\id{Clusters}|}{|\id{Primitive~clusters}|}
\end{equation}


\begin{table}[h]
\vspace*{1em}
\let\A\relax
\newlength{\A} \settowidth{\A}{288}
\let\B\relax
\newlength{\B}
\settowidth{\B}{288}
\let\Cl\relax
\newlength{\Cl}
\settowidth{\Cl}{288}
\let\Ac\relax
\newlength{\Ac}
\settowidth{\Ac}{}
\let\Bc\relax
\newlength{\Bc}
\settowidth{\Bc}{}
\let\Abc\relax
\newlength{\Abc}
\settowidth{\Abc}{}
\let\Pwa\relax
\newlength{\Pwa}
\settowidth{\Pwa}{\%}
\centering\begin{tabular}{lccccc}
  \toprule
   & \multicolumn{1}{c}{Tomcat}  & \multicolumn{1}{c}{Hibernate} & \multicolumn{1}{c}{Camel}  & \multicolumn{1}{c}{Solr} & \multicolumn{1}{c}{}\\
  \midrule
  Log4j statements          & \makebox[\Ac][c]{1098}                                  & \makebox[\Bc][c]{128}  & \makebox[\Abc][c]{632}  & \makebox[\Abc][c]{1471} \\
 LMs               & \makebox[\Ac][c]{658}                                  & \makebox[\Bc][c]{81}     & \makebox[\Abc][c]{490}& \makebox[\Abc][c]{818}
\\\midrule

 Primitive clusters  & \makebox[\Ac][c]{\makebox[\A][r]{1098}}                 & \makebox[\Bc][c]{\makebox[\B][r]{128}}                 & \makebox[\Abc][c]{\makebox[\Cl][r]{632}}  & \makebox[\Abc][c]{\makebox[\Cl][r]{1471}}  \\

 Clusters  & \makebox[\Ac][c]{\makebox[\A][r]{29}}                 & \makebox[\Bc][c]{\makebox[\B][r]{7}}                 & \makebox[\Abc][c]{\makebox[\Cl][r]{24}} & \makebox[\Abc][c]{\makebox[\Cl][r]{38}}\\


  Generalized clusters  & \makebox[\Ac][c]{\makebox[\A][r]{14}}                 & \makebox[\Bc][c]{\makebox[\B][r]{4}}                 & \makebox[\Abc][c]{\makebox[\Cl][r]{9}}  & \makebox[\Abc][c]{\makebox[\Cl][r]{14}} \\


  Singleton clusters       & \makebox[\Ac][c]{\makebox[\A][r]{15}}                 & \makebox[\Bc][c]{\makebox[\B][r]{3}}                 & \makebox[\Abc][c]{\makebox[\Cl][r]{13}} & \makebox[\Abc][c]{\makebox[\Cl][r]{24}} \\\midrule

  Reduction                       & \makebox[\Ac][c]{\makebox[\A][r]{97\%\hspace*{-\Pwa}}} & \makebox[\Bc][c]{\makebox[\B][r]{94\%\hspace*{-\Pwa}}} &\makebox[\Bc][c]{\makebox[\B][r]{96\%\hspace*{-\Pwa}}}& \makebox[\Ac][c]{\makebox[\A][r]{97\%\hspace*{-\Pwa}}} \\


  \toprule
\end{tabular}
%\caption{Within-version experiment.}
\caption{The experimental results.}
%\caption{Experimental results for the the software systems}
\label{tab_results_1} \vspace*{1em}
\end{table}
%[width = 1\textwidth, height = 0.4\textheight]

\begin{sidewaysfigure} [p]
    \centering
  \centering\includegraphics [width = 1\textwidth, height = 0.5\textheight] {Charts/Histograms.png}
  \caption{Histograms of the number of LMs per cluster.}
  \label{fig:histograms}
\end{sidewaysfigure}


\subsection{Analysis}  \label{analysis}
The first research question is : \emph{"Is it possible to find patterns of where log statements occur in source code?"}. As it is shown in Table~\ref{tab_results_1}, the number of clusters has been reduced by more than 90\% in all the studied systems, indicating that developers follow some patterns for locating the log statements in source code. Furthermore, histograms depicted in Figure~\ref{fig:histograms} show that in all the studied systems, a few clusters contain a large number of LMs; however, the other clusters contain a very few number of LMs (only one or two). This indicates that in these cases developers follow a more complex or rare way of locating log statements. These exceptions might also happen due to the poor usage of logging calls in source code, which impacts the quality of the entire system negatively.

The second research question is : \emph{``What common structural characteristics do logged methods have?''}
To address this question, I have manually went through the LUSs of anti-unifiers to identify the common structural characteristics of locating the log statements in source code.

%a few rare exception
%ADD-> THE USEAGE WITH AN EXCEPTION

\subsubsection{\emph{Categorizing logging usage}} \label{categories}
In this section, I will describe the anti-unifiers of logging usage by examining the LUSs produced by \tool{ELUS}. In general, there are five categories of anti-unifiers in the logging usage. Each category represents one cluster of each software system where their anti-unifiers are corresponded, as they have common structural characteristics. Also, these clusters contain a large number of LMs, that is, their anti-unifier represents a common way of locating log statements in source code. In the following sections, I will describe the common structural characteristics of each category represented by the anti-unifiers. In addition, Figure~\ref{fig:categories} presents the number of LMs in each category and its percentage to the total number of LMs for each of the software systems.

\begin{sidewaysfigure} [p]
   \centering\includegraphics [width = 1\textwidth, height = 0.7\textheight]{Charts/Categories.png}
  \caption{The distribution of the categories of anti-unifiers in the logging usage.}
  \label{fig:categories}
\end{sidewaysfigure}


% how to compare?

\subsubsection{\emph{A. Exception Catch-block Logging}}  \label{Exception catch-block logging}
The main common structural characteristics of the anti-unifiers of this category are the \code{try} and \code{catch} \code{statements}, where the \code{log statements} are located inside the body of a \code{Catch Clause}. As shown in Figure~\ref{fig:categories}, 14\% to 52\% of the total LMs are described by the anti-unifiers of this category, and it is the most commonly used logging usage category in the \name{Tomcat} and \name{Hibernate} software systems. The popularity of this category among all the studied systems is due to the fact that exception handling using the \code{try}/\code{catch} blocks is a common error handling technique in the Java programming language.

%a large portion of LMs are described by the anti-unifiers of this category.

\subsubsection{\emph{B. Conditional Logging}}  \label{conditional logging}
In this category, \code{log statements} are enclosed by \code{if} statements that their expressions are mostly among \code{Infix} \code{Expression}, \code{Method} \code{Invocation}, or \code{Binary} \code{Expression} nodes. The \code{Infix} \code{Expressions} mostly either checks the equality of an expression to the \code{Null} \code{Literal} or tests the validity of the value of a variable; the \code{if} \code{statements} with \code{Method} \code{Invocations} mostly check if the return value of an invoked method is an indicator of a potential problem within the system; and the \code{if} \code{statements} with \code{Binary Expressions} mostly checks if a \code{Boolean} \code{Literal} is incorrect. As shown in Figure~\ref{fig:categories}, 16\% to 37\% of the total LMs are described by the anti-unifiers of this category, and it is the most commonly used logging category in the \name{Solr} system.

\subsubsection{\emph{C. Method Logging}}  \label{method logging}
In this category, the \code{log statements} are located inside the body of \code{Method Declaration} nodes. A common structural characteristic of the anti-unifiers in this category is that they mostly use the \code{Throw Statements} to throw an exception if an error occurs. The percentage of LMs that are described by the anti-unifiers of this category ranges from 3\% to 51\%, and it is the most common logging usage category in the \name{Camel} software system. This suggests that developers use logging to record important method granularity information about the state of a software system. This information might be used later to detect the root causes of an application problem.
% %?
% throw exception



\subsubsection{\emph{D. Control Flow Logging}}  \label{Exception try-block logging}
In this category, the \code{log statements} are located inside the body of either \code{switch-} or \code{if-then-else-} statements. These \code{log statements} can be used to reveal necessary information to track the location of root causes of a potential problem in a software system. According to the Figure~\ref{fig:categories}, 0\% to 5\% of the total LMs are described by the anti-unifiers of this category.


\subsubsection{\emph{E. Exception Try-block Logging}}  \label{Exception try-block logging}
In this category, the \code{log statements} are located inside the body of the \code{try} \code{statement} of \code{try}/\code{catch} blocks. These \code{log statements} can be used to record important information about the code that may throw an exception. According to the Figure~\ref{fig:categories}, 0\% to 7\% of the total LMs of the studied systems are described by the anti-unifiers of this category.

%COMPARE SYSTEMS???
%CATEGORIES FIGURE CHNAGE???

\section{Evaluation}  \label{evaluation}
\RW{For constrained variables, the precision should be 100\%.  The fact that it is not means that there are some bugs.  There is no point in pretending otherwise; you are better off pointing this out.  It's OK: all software contains bugs.  Later, in the Discussion, you should point out that intermediate forms of constraint are possible: instead of constraining to only the exactly desired substitutions, you can constrain to the legal types of nodes (like methodInvocation) that can be used to substitute a variable.  The (still open) question is if that would yield better results than unconstrained variables.}

An empirical study is conducted to evaluate the quality of the anti-unifiers generated by \code{ELUS} in describing the location of log statements in source code. Section~\ref{precision} describe the process of evaluating the precision and recall of \tool{ELUS}.


\subsubsection{\emph{Calculating the precision and recall}}  \label{precision}
To find the locations in source code that are described by an anti-unifier using \tool{ELUS}, I applied the \func{Determine-Locations} algorithm, which takes the anti-unifier and a list of all methods in source code and outputs a list of methods that their AUAST matches the anti-unifier AUAST. This algorithm anti-unifies each method in the list with the anti-unifier using the \func{Antiunify} algorithm described in Section~\label{meth-antiUnifier}(Lines~2--3). If the result equals the anti-unifier, that method will be added to the list of locations matching the anti-unifier (Lines~4--5). \func{Equals} is a procedure that takes two AUAST nodes and checks whether they are equal or not. To evaluate the generalizability of the anti-unifiers, I have implemented this procedure in two ways: (1) when variables are considered to be \emph{constrained}, it tests that the non-variable nodes are identical in the two AUASTs and checks if the constraints of variable are identical or not. (2) When variables are considered to be \emph{unconstrained}, it tests that the non-variable nodes are identical in the two AUASTs, but permits unconstrained variables to differ. I ran my tool on the source code of the four studied systems and applied this algorithm to find the locations in the code that matches the structure of the generated anti-unifiers. Then, the precision and recall metrics are calculated using the equations~\ref{precision_eq} and~\ref{recall_eq}, respectively.


\begin{algorithm}
\caption{\func{Determine-Locations}($\id{antiUnifier}$,$\id{methods}$) finds the locations in source code that matches an anti-unifier.}
\label{alg-determine}
\begin{algorithmic}[1]
\DetermineLocations
    \State $\id{locations} \gets \func{()}$
    \For {$\id{method} \in \id{methods}$}
    \State $\id{result} \gets  \func{AntiUnify}(\id{antiUnfier},\id{method})$
		\If {$\func{Equals}(\id{result},\id{antiUnifier})$ }	
				 	\State{$\func{Append}(\id{method},\id{locations})$ }
		\EndIf 		
		\EndFor
 \Return $\id{locations} $  	
  \end{algorithmic}
\end{algorithm}

\begin{equation}\label{precision_eq}
\id{precision} = \frac{\id{TP}}{{\id{TP}+\id{FP}}}
\end{equation}


\begin{equation}\label{recall_eq}
\id{recall} = \frac{\id{TP}}{{\id{TP}+\id{FN}}}
\end{equation}


Where TP is the number of correct locations obtained, FP is the number of incorrect locations retrieved, and FN is the number of correct locations that are not retrieved. Figures~\ref{fig:precision} and \ref{fig:recall} show the precision and recall results for each software system where the experiment was run once with constrained variables and once with unconstrained variables.


\begin{figure} [H]
  \centering\includegraphics [width = 0.7\textwidth, height = 0.3\textheight]{Charts/Precision.png}
  \caption{The precision of \tool{ELUS}.}
  \label{fig:precision}
\end{figure}

\begin{figure} [H]
  \centering\includegraphics [width = 0.7\textwidth, height = 0.3\textheight]{Charts/Recall.png}
  \caption{The recall of \tool{ELUS}.}
  \label{fig:recall}
\end{figure}

\subsubsection{\emph{Precision Results}}  \label{precision-results}
The green and yellow bars in Figure~\ref{fig:precision}  show the precision results when the experiment was run with constrained and unconstrained variables, respectively. I have also calculated the overall average precision of \tool{ELUS}, by averaging the precision values between the four software systems. The average precision for \tool{ELUS} is 84\% and 32\% for constrained and unconstrained variable experiments, respectively. In general, the precision for constrained variables are fairly high. The main reason behind the high precision is that in these cases the variables can only be substituted with some particular nodes, which makes the anti-unifier very specific. Furthermore, according to the Figure~\ref{fig:precision}, the precision is fairly low for unconstrained variables. The main reason for the low precision for these cases is the fact that the unconstrained variables can be substituted by any nodes, which makes the anti-unifiers too general. As a result, the tool finds many incorrect locations the matches the anti-unifiers.

\subsubsection{\emph{Recall Results}}  \label{recall-results}
The green and yellow bars in Figure~\ref{fig:recall}  show the recall results when the experiment was run with constrained and unconstrained variables, respectively. I have also calculated the overall average recall of \tool{ELUS}, by averaging the recall values between the studied systems. The average recall for \tool{ELUS} is 80\% and 97\% for the constrained and unconstrained variable experiments, respectively. In general, when variables are constrained, \tool{ELUS} can detect many correct locations, as the recalls for all the studied systems are fairly high. Also, \tool{ELUS} can detect most of the correct locations in source code when no constraints are taken on variable nodes.

The main reason behind \tool{ELUS}`s failure in detecting the correct locations is the potential complexities in constructing anti-unifiers from a large set of source code fragments. As in some cases, the anti-unifier might not maintain the correct locations of nodes in the AST hierarchy, and thus \tool{ELUS} would not be able to detect correct locations of log statements in the source code.


%ADDDDD
% assess the generalizability of the anti-unifiers --> in between
\RW{Ah, I see that you have a note in here about the intermediate constraints.}
%In general,  the tool retrieved some locations matching the anti-unifiers, while in fact they do not match.
%the tool failed to retrieve the correct locations, and in other cases



\section{Usage}  \label{usageELUS}
The insightful findings of my characterization study regarding the logging usage in several real-world software systems can be used to enhance the quality of existing logging practices by providing some logging guidelines for developers. For example, Figure~\ref{inapproprate-ex1} shows a logged method that belongs to a singleton cluster in my experiment. This \name{Java} method is an example of a poor usage of a log statement in code, as the list \code{liveNodes} can be \code{null}, and thus a \code{NullPointerException} can be thrown causing a system crash. To enhance the quality of the logging usage in this code snippet, a developer my look at our findings to be informed of how usually other developers locate log statements in similar situations. As noted in Section~\ref{categories}, to avoid the \code{NUllPointerException}, developers usually insert the logging call into the body of an \code{if} statement to check if the value of the variable needed to be logged is not \code{null}. Hence, she can improve the quality of the logging usage in this example by inserting the logging call inside an \code{if} statement and log the needful information if the value of the list \code{liveNodes} is not \code{null} (Lines~6--8 of Figure~\ref{approprate-ex1}). This example demonstrates how these findings can be used in practice to improve the quality of logging practices.
% in real-world application.


\begin{figure}[p]
\def\baselinestretch{1}
\begin{lstlisting}[escapechar=!]
public void setUp() throws Exception {
    SolrZkClient zkClient=new SolrZkClient(zkServer.getZkAddress(),AbstractZkTestCase.TIMEOUT);
    for (int i=0; i < 30; i++) {
       List<String> liveNodes=zkClient.getChildren("/live_nodes",null,true);
       Thread.sleep(1000);
       !\colorbox{yellowGreen}{log.info("Waiting for more nodes to come up, now: " + liveNodes.size());}! 
    }
}
\end{lstlisting}
\caption[Example 1: An example of an inappropriate usage of a log statement in a Java method.]{An example of an inappropriate usage of a log statement in a Java method.\label{inapproprate-ex1}}
\end{figure}



\begin{figure}[p]
\def\baselinestretch{1}
\begin{lstlisting}[escapechar=!]
public void setUp() throws Exception {
    SolrZkClient zkClient=new SolrZkClient(zkServer.getZkAddress(),AbstractZkTestCase.TIMEOUT);
    for (int i=0; i < 30; i++) {
       List<String> liveNodes=zkClient.getChildren("/live_nodes",null,true);
       Thread.sleep(1000);
       if (liveNodes \neq null) {
          !\colorbox{yellowGreen}{log.info("Waiting for more nodes to come up, now: " + liveNodes.size());}! 
       }
    }
}
\end{lstlisting}
\caption[Example 1: An example  for the purpose of enhancing the logging usage in the Java method of Example.]{Modified Java methed of Figure~\ref{inapproprate-ex1} for the purpose of enhancing the logging usage.\label{approprate-ex1}}
\end{figure}



\section{Summary}
I conducted an experimental study to characterize the location of log statements by applying my tool on the source code of four full software systems that make use of the \code{Apache Log4j} logging framework. My tool inputs the source code of these systems, extracts ASTs of LMs, applies the proposed anti-unification and clustering algorithms, and outputs the anti-unifier for each cluster. I also conducted an experimental study to evaluate the precision and the recall of \tool{ELUS} in constructing the anti-unifiers that describe the location of log statements in source code. This experiment shows that \tool{ELUS} has achieved promising results in terms of precision and recall. Furthermore, The results taken from the characterization experiment shows that there are common ways of locating log statements. I manually examined the detailed view of structural generalizations and categorized the anti-unifiers of logging usage. In the last section of this chapter, I provided an example to demonstrate the usage of the findings of my characterization study in practice.


% In summary, this experiment shows that \tool{ELUS} has achieved promising results in terms of precision and recall metrics.

% My analysis has resulted in ... different anti-unifiers in the logging usage.

% figure out the common structural characteristics of LMs in each cluster.
%I found out that most log statements are embedded inside ....
