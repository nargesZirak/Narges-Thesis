public class PluginJAR {
  public String getPath(){
    return path;
  }
  public String getCachePath(){
    return cachePath;
  }
  public File getFile(){
    return file;
  }
  public JARClassLoader getClassLoader(){
    return classLoader;
  }
  public synchronized ZipFile getZipFile() throws IOException {
    if (zipFile == null) {
      zipFile=new ZipFile(path);
    }
    return zipFile;
  }
  public ActionSet getActions(){
    return getActionSet();
  }
  public ActionSet getActionSet(){
    return actions;
  }
  public ActionSet getBrowserActionSet(){
    return browserActions;
  }
  public boolean checkDependencies(){
    if (plugin == null)     return true;
    int i=0;
    boolean ok=true;
    boolean optional=false;
    String name=plugin.getClassName();
    String dep;
    while ((dep=jEdit.getProperty("plugin." + name + ".depend."+ i++)) != null) {
      if (dep.startsWith("optional ")) {
        optional=true;
        dep=dep.substring("optional ".length());
      }
      int index=dep.indexOf(' ');
      if (index == -1) {
        ok=false;
        continue;
      }
      String what=dep.substring(0,index);
      String arg=dep.substring(index + 1);
      if (what.equals("jdk")) {
        if (!optional && MiscUtilities.compareStrings(System.getProperty("java.version"),arg,false) < 0) {
          String[] args={arg,System.getProperty("java.version")};
          jEdit.pluginError(path,"plugin-error.dep-jdk",args);
          ok=false;
        }
      }
 else       if (what.equals("jedit")) {
        if (arg.length() != 11) {
          ok=false;
        }
        if (!optional && MiscUtilities.compareStrings(jEdit.getBuild(),arg,false) < 0) {
          String needs=MiscUtilities.buildToVersion(arg);
          String[] args={needs,jEdit.getVersion()};
          jEdit.pluginError(path,"plugin-error.dep-jedit",args);
          ok=false;
        }
      }
 else       if (what.equals("plugin")) {
        int index2=arg.indexOf(' ');
        if (index2 == -1) {
          ok=false;
          continue;
        }
        String pluginName=arg.substring(0,index2);
        String needVersion=arg.substring(index2 + 1);
        String currVersion=jEdit.getProperty("plugin." + pluginName + ".version");
        EditPlugin plugin=jEdit.getPlugin(pluginName);
        if (plugin == null) {
          if (!optional) {
            String[] args={needVersion,pluginName};
            jEdit.pluginError(path,"plugin-error.dep-plugin.no-version",args);
            ok=false;
          }
        }
 else         if (MiscUtilities.compareStrings(currVersion,needVersion,false) < 0) {
          if (!optional) {
            String[] args={needVersion,pluginName,currVersion};
            jEdit.pluginError(path,"plugin-error.dep-plugin",args);
            ok=false;
          }
        }
 else         if (plugin instanceof EditPlugin.Broken) {
          if (!optional) {
            String[] args={pluginName};
            jEdit.pluginError(path,"plugin-error.dep-plugin.broken",args);
            ok=false;
          }
        }
 else {
          PluginJAR jar=plugin.getPluginJAR();
          jar.theseRequireMe.add(path);
          weRequireThese.add(jar.getPath());
        }
      }
 else       if (what.equals("class")) {
        if (!optional) {
          try {
            classLoader.loadClass(arg,false);
          }
 catch (          Exception e) {
            String[] args={arg};
            jEdit.pluginError(path,"plugin-error.dep-class",args);
            ok=false;
          }
        }
      }
 else {
        ok=false;
      }
    }
    String jars=jEdit.getProperty("plugin." + plugin.getClassName() + ".jars");
    if (jars != null) {
      String dir=MiscUtilities.getParentOfPath(path);
      StringTokenizer st=new StringTokenizer(jars);
      while (st.hasMoreTokens()) {
        String jarPath=MiscUtilities.constructPath(dir,st.nextToken());
        PluginJAR jar=jEdit.getPluginJAR(jarPath);
        if (jar == null) {
          String[] args={jarPath};
          jEdit.pluginError(path,"plugin-error.missing-jar",args);
          ok=false;
        }
 else {
          weRequireThese.add(jarPath);
          jar.theseRequireMe.add(path);
        }
      }
    }
    if (!ok)     breakPlugin();
    return ok;
  }
  public String[] getDependentPlugins(){
    return (String[])theseRequireMe.toArray(new String[theseRequireMe.size()]);
  }
  public EditPlugin getPlugin(){
    return plugin;
  }
  public void activatePlugin(){
synchronized (this) {
      if (activated) {
        return;
      }
      activated=true;
    }
    if (!(plugin instanceof EditPlugin.Deferred))     return;
    String className=plugin.getClassName();
    try {
      Class clazz=classLoader.loadClass(className,false);
      int modifiers=clazz.getModifiers();
      if (Modifier.isInterface(modifiers) || Modifier.isAbstract(modifiers) || !EditPlugin.class.isAssignableFrom(clazz)) {
        breakPlugin();
        return;
      }
      plugin=(EditPlugin)clazz.newInstance();
      plugin.jar=(EditPlugin.JAR)this;
    }
 catch (    Throwable t) {
      breakPlugin();
      String[] args={t.toString()};
      jEdit.pluginError(path,"plugin-error.start-error",args);
      return;
    }
    if (jEdit.isMainThread() || SwingUtilities.isEventDispatchThread()) {
      startPlugin();
    }
 else {
      startPluginLater();
    }
    EditBus.send(new PluginUpdate(this,PluginUpdate.ACTIVATED,false));
  }
  public void activatePluginIfNecessary(){
    if (!(plugin instanceof EditPlugin.Deferred && plugin != null))     return;
    String className=plugin.getClassName();
    String activate=jEdit.getProperty("plugin." + className + ".activate");
    if (activate == null) {
      if (!jEdit.isMainThread()) {
        breakPlugin();
        jEdit.pluginError(path,"plugin-error.not-42",null);
      }
 else       activatePlugin();
    }
 else {
      boolean load=false;
      StringTokenizer st=new StringTokenizer(activate);
      while (st.hasMoreTokens()) {
        String prop=st.nextToken();
        boolean value=jEdit.getBooleanProperty(prop);
        if (value) {
          load=true;
          break;
        }
      }
      if (load)       activatePlugin();
    }
  }
  public void deactivatePlugin(  boolean exit){
    if (!activated)     return;
    if (!exit) {
      Buffer buffer=jEdit.getFirstBuffer();
      while (buffer != null) {
        if (buffer.getFoldHandler() != null && buffer.getFoldHandler().getClass().getClassLoader() == classLoader) {
          buffer.setFoldHandler(new DummyFoldHandler());
        }
        buffer=buffer.getNext();
      }
    }
    if (plugin != null && !(plugin instanceof EditPlugin.Broken)) {
      if (plugin instanceof EBPlugin)       EditBus.removeFromBus((EBPlugin)plugin);
      try {
        plugin.stop();
      }
 catch (      Throwable t) {
      }
      plugin=new EditPlugin.Deferred(plugin.getClassName());
      plugin.jar=(EditPlugin.JAR)this;
      EditBus.send(new PluginUpdate(this,PluginUpdate.DEACTIVATED,exit));
      if (!exit) {
        String activate=jEdit.getProperty("plugin." + plugin.getClassName() + ".activate");
        if (activate == null) {
          breakPlugin();
          jEdit.pluginError(path,"plugin-error.not-42",null);
        }
      }
    }
    activated=false;
  }
  public URL getDockablesURI(){
    return dockablesURI;
  }
  public URL getServicesURI(){
    return servicesURI;
  }
  public String toString(){
    if (plugin == null)     return path;
 else     return path + ",class=" + plugin.getClassName();
  }
  static PluginCacheEntry getPluginCache(  PluginJAR plugin){
    String jarCachePath=plugin.getCachePath();
    if (jarCachePath == null)     return null;
    DataInputStream din=null;
    try {
      PluginCacheEntry cache=new PluginCacheEntry();
      cache.plugin=plugin;
      cache.modTime=plugin.getFile().lastModified();
      din=new DataInputStream(new BufferedInputStream(new FileInputStream(jarCachePath)));
      if (cache.read(din))       return cache;
 else {
        return null;
      }
    }
 catch (    FileNotFoundException fnf) {
      return null;
    }
catch (    IOException io) {
      return null;
    }
 finally {
      try {
        if (din != null)         din.close();
      }
 catch (      IOException io) {
      }
    }
  }
  static void setPluginCache(  PluginJAR plugin,  PluginCacheEntry cache){
    String jarCachePath=plugin.getCachePath();
    if (jarCachePath == null)     return;
    DataOutputStream dout=null;
    try {
      dout=new DataOutputStream(new BufferedOutputStream(new FileOutputStream(jarCachePath)));
      cache.write(dout);
      dout.close();
    }
 catch (    IOException io) {
      try {
        if (dout != null)         dout.close();
      }
 catch (      IOException io2) {
      }
      new File(jarCachePath).delete();
    }
  }
  PluginJAR(  File file){
    this.path=file.getPath();
    String jarCacheDir=jEdit.getJARCacheDirectory();
    if (jarCacheDir != null) {
      cachePath=MiscUtilities.constructPath(jarCacheDir,file.getName() + ".summary");
    }
    this.file=file;
    classLoader=new JARClassLoader(this);
    actions=new ActionSet();
  }
  void init(){
    boolean initialized=false;
    PluginCacheEntry cache=getPluginCache(this);
    if (cache != null) {
      loadCache(cache);
      classLoader.activate();
      initialized=true;
    }
 else {
      try {
        cache=generateCache();
        if (cache != null) {
          setPluginCache(this,cache);
          classLoader.activate();
          initialized=true;
        }
      }
 catch (      IOException io) {
        String[] args={io.toString()};
        jEdit.pluginError(path,"plugin-error.load-error",args);
        uninit(false);
      }
    }
  }
  void uninit(  boolean exit){
    deactivatePlugin(exit);
    if (!exit) {
      Iterator iter=weRequireThese.iterator();
      while (iter.hasNext()) {
        String path=(String)iter.next();
        PluginJAR jar=jEdit.getPluginJAR(path);
        if (jar != null)         jar.theseRequireMe.remove(this.path);
      }
      classLoader.deactivate();
      BeanShell.resetClassManager();
      if (actions != null)       jEdit.getActionContext().removeActionSet(actions);
      if (browserActions != null)       VFSBrowser.getActionContext().removeActionSet(browserActions);
      DockableWindowManager.unloadDockableWindows(this);
      ServiceManager.unloadServices(this);
      jEdit.removePluginProps(properties);
      try {
        if (zipFile != null) {
          zipFile.close();
          zipFile=null;
        }
      }
 catch (      IOException io) {
      }
    }
  }
  String[] getClasses(){
    return classes;
  }
  private String path;
  private String cachePath;
  private File file;
  private JARClassLoader classLoader;
  private ZipFile zipFile;
  private Properties properties;
  private String[] classes;
  private ActionSet actions;
  private ActionSet browserActions;
  private EditPlugin plugin;
  private URL dockablesURI;
  private URL servicesURI;
  private boolean activated;
  private List theseRequireMe=new LinkedList();
  private List weRequireThese=new LinkedList();
  private void actionsPresentButNotCoreClass(){
    actions.setLabel("MISSING PLUGIN CORE CLASS");
  }
  private void loadCache(  PluginCacheEntry cache){
    classes=cache.classes;
    if (cache.cachedProperties != null) {
      properties=cache.cachedProperties;
      jEdit.addPluginProps(cache.cachedProperties);
    }
    if (cache.actionsURI != null && cache.cachedActionNames != null) {
      actions=new ActionSet(this,cache.cachedActionNames,cache.cachedActionToggleFlags,cache.actionsURI);
    }
    if (cache.browserActionsURI != null && cache.cachedBrowserActionNames != null) {
      browserActions=new ActionSet(this,cache.cachedBrowserActionNames,cache.cachedBrowserActionToggleFlags,cache.browserActionsURI);
      VFSBrowser.getActionContext().addActionSet(browserActions);
    }
    if (cache.dockablesURI != null && cache.cachedDockableNames != null && cache.cachedDockableActionFlags != null) {
      dockablesURI=cache.dockablesURI;
      DockableWindowManager.cacheDockableWindows(this,cache.cachedDockableNames,cache.cachedDockableActionFlags);
    }
    if (actions.size() != 0)     jEdit.addActionSet(actions);
    if (cache.servicesURI != null && cache.cachedServices != null) {
      servicesURI=cache.servicesURI;
      for (int i=0; i < cache.cachedServices.length; i++) {
        ServiceManager.Descriptor d=cache.cachedServices[i];
        ServiceManager.registerService(d);
      }
    }
    if (cache.pluginClass != null) {
      if (jEdit.getPlugin(cache.pluginClass) != null) {
        jEdit.pluginError(path,"plugin-error.already-loaded",null);
        uninit(false);
      }
 else {
        String label=jEdit.getProperty("plugin." + cache.pluginClass + ".name");
        actions.setLabel(jEdit.getProperty("action-set.plugin",new String[]{label}));
        plugin=new EditPlugin.Deferred(cache.pluginClass);
        plugin.jar=(EditPlugin.JAR)this;
      }
    }
 else {
      if (actions.size() != 0)       actionsPresentButNotCoreClass();
    }
  }
  private PluginCacheEntry generateCache() throws IOException {
    properties=new Properties();
    LinkedList classes=new LinkedList();
    ZipFile zipFile=getZipFile();
    List plugins=new LinkedList();
    PluginCacheEntry cache=new PluginCacheEntry();
    cache.modTime=file.lastModified();
    cache.cachedProperties=new Properties();
    Enumeration entries=zipFile.entries();
    while (entries.hasMoreElements()) {
      ZipEntry entry=(ZipEntry)entries.nextElement();
      String name=entry.getName();
      String lname=name.toLowerCase();
      if (lname.equals("actions.xml")) {
        cache.actionsURI=classLoader.getResource(name);
      }
 else       if (lname.equals("browser.actions.xml")) {
        cache.browserActionsURI=classLoader.getResource(name);
      }
 else       if (lname.equals("dockables.xml")) {
        dockablesURI=classLoader.getResource(name);
        cache.dockablesURI=dockablesURI;
      }
 else       if (lname.equals("services.xml")) {
        servicesURI=classLoader.getResource(name);
        cache.servicesURI=servicesURI;
      }
 else       if (lname.endsWith(".props")) {
        InputStream in=classLoader.getResourceAsStream(name);
        properties.load(in);
        in.close();
      }
 else       if (name.endsWith(".class")) {
        String className=MiscUtilities.fileToClass(name);
        if (className.endsWith("Plugin")) {
          plugins.add(className);
        }
        classes.add(className);
      }
    }
    cache.cachedProperties=properties;
    jEdit.addPluginProps(properties);
    this.classes=cache.classes=(String[])classes.toArray(new String[classes.size()]);
    String label=null;
    Iterator iter=plugins.iterator();
    while (iter.hasNext()) {
      String className=(String)iter.next();
      String _label=jEdit.getProperty("plugin." + className + ".name");
      String version=jEdit.getProperty("plugin." + className + ".version");
      if (_label == null || version == null) {
        Log.log(Log.WARNING,this,"Ignoring: " + className);
      }
 else {
        cache.pluginClass=className;
        if (jEdit.getPlugin(className) != null) {
          jEdit.pluginError(path,"plugin-error.already-loaded",null);
          return null;
        }
 else {
          plugin=new EditPlugin.Deferred(className);
          plugin.jar=(EditPlugin.JAR)this;
          label=_label;
        }
        break;
      }
    }
    if (cache.actionsURI != null) {
      actions=new ActionSet(this,null,null,cache.actionsURI);
      actions.load();
      cache.cachedActionNames=actions.getCacheableActionNames();
      cache.cachedActionToggleFlags=new boolean[cache.cachedActionNames.length];
      for (int i=0; i < cache.cachedActionNames.length; i++) {
        cache.cachedActionToggleFlags[i]=jEdit.getBooleanProperty(cache.cachedActionNames[i] + ".toggle");
      }
    }
    if (cache.browserActionsURI != null) {
      browserActions=new ActionSet(this,null,null,cache.browserActionsURI);
      browserActions.load();
      VFSBrowser.getActionContext().addActionSet(browserActions);
      cache.cachedBrowserActionNames=browserActions.getCacheableActionNames();
      cache.cachedBrowserActionToggleFlags=new boolean[cache.cachedBrowserActionNames.length];
      for (int i=0; i < cache.cachedBrowserActionNames.length; i++) {
        cache.cachedBrowserActionToggleFlags[i]=jEdit.getBooleanProperty(cache.cachedBrowserActionNames[i] + ".toggle");
      }
    }
    if (dockablesURI != null) {
      DockableWindowManager.loadDockableWindows(this,dockablesURI,cache);
    }
    if (actions.size() != 0) {
      if (label != null) {
        actions.setLabel(jEdit.getProperty("action-set.plugin",new String[]{label}));
      }
 else       actionsPresentButNotCoreClass();
      jEdit.addActionSet(actions);
    }
    if (servicesURI != null) {
      ServiceManager.loadServices(this,servicesURI,cache);
    }
    return cache;
  }
  private void startPlugin(){
    try {
      plugin.start();
    }
 catch (    Throwable t) {
      breakPlugin();
      String[] args={t.toString()};
      jEdit.pluginError(path,"plugin-error.start-error",args);
    }
    if (plugin instanceof EBPlugin) {
      if (jEdit.getProperty("plugin." + plugin.getClassName() + ".activate") == null) {
        ((EBComponent)plugin).handleMessage(new org.gjt.sp.jedit.msg.PropertiesChanged(null));
      }
      EditBus.addToBus((EBPlugin)plugin);
    }
    Buffer buffer=jEdit.getFirstBuffer();
    while (buffer != null) {
      FoldHandler handler=FoldHandler.getFoldHandler(buffer.getStringProperty("folding"));
      if (buffer.getFoldHandler() != null && handler != null && handler != buffer.getFoldHandler()) {
        buffer.setFoldHandler(handler);
      }
      buffer=buffer.getNext();
    }
  }
  private void startPluginLater(){
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        if (!activated)         return;
        startPlugin();
      }
    }
);
  }
  private void breakPlugin(){
    plugin=new EditPlugin.Broken(plugin.getClassName());
    plugin.jar=(EditPlugin.JAR)this;
    uninit(false);
    jEdit.addPluginProps(properties);
  }
public static class PluginCacheEntry {
    public static final int MAGIC=0xB7A2E420;
    public PluginJAR plugin;
    public long modTime;
    public String[] classes;
    public URL actionsURI;
    public String[] cachedActionNames;
    public boolean[] cachedActionToggleFlags;
    public URL browserActionsURI;
    public String[] cachedBrowserActionNames;
    public boolean[] cachedBrowserActionToggleFlags;
    public URL dockablesURI;
    public String[] cachedDockableNames;
    public boolean[] cachedDockableActionFlags;
    public URL servicesURI;
    public ServiceManager.Descriptor[] cachedServices;
    public Properties cachedProperties;
    public String pluginClass;
    public boolean read(    DataInputStream din) throws IOException {
      int cacheMagic=din.readInt();
      if (cacheMagic != MAGIC)       return false;
      String cacheBuild=readString(din);
      if (!cacheBuild.equals(jEdit.getBuild()))       return false;
      long cacheModTime=din.readLong();
      if (cacheModTime != modTime)       return false;
      actionsURI=readURI(din);
      cachedActionNames=readStringArray(din);
      cachedActionToggleFlags=readBooleanArray(din);
      browserActionsURI=readURI(din);
      cachedBrowserActionNames=readStringArray(din);
      cachedBrowserActionToggleFlags=readBooleanArray(din);
      dockablesURI=readURI(din);
      cachedDockableNames=readStringArray(din);
      cachedDockableActionFlags=readBooleanArray(din);
      servicesURI=readURI(din);
      int len=din.readInt();
      if (len == 0)       cachedServices=null;
 else {
        cachedServices=new ServiceManager.Descriptor[len];
        for (int i=0; i < len; i++) {
          ServiceManager.Descriptor d=new ServiceManager.Descriptor(readString(din),readString(din),null,plugin);
          cachedServices[i]=d;
        }
      }
      classes=readStringArray(din);
      cachedProperties=readMap(din);
      pluginClass=readString(din);
      return true;
    }
    public void write(    DataOutputStream dout) throws IOException {
      dout.writeInt(MAGIC);
      writeString(dout,jEdit.getBuild());
      dout.writeLong(modTime);
      writeString(dout,actionsURI);
      writeStringArray(dout,cachedActionNames);
      writeBooleanArray(dout,cachedActionToggleFlags);
      writeString(dout,browserActionsURI);
      writeStringArray(dout,cachedBrowserActionNames);
      writeBooleanArray(dout,cachedBrowserActionToggleFlags);
      writeString(dout,dockablesURI);
      writeStringArray(dout,cachedDockableNames);
      writeBooleanArray(dout,cachedDockableActionFlags);
      writeString(dout,servicesURI);
      if (cachedServices == null)       dout.writeInt(0);
 else {
        dout.writeInt(cachedServices.length);
        for (int i=0; i < cachedServices.length; i++) {
          writeString(dout,cachedServices[i].clazz);
          writeString(dout,cachedServices[i].name);
        }
      }
      writeStringArray(dout,classes);
      writeMap(dout,cachedProperties);
      writeString(dout,pluginClass);
    }
    private String readString(    DataInputStream din) throws IOException {
      int len=din.readInt();
      if (len == 0)       return null;
      char[] str=new char[len];
      for (int i=0; i < len; i++)       str[i]=din.readChar();
      return new String(str);
    }
    private URL readURI(    DataInputStream din) throws IOException {
      String str=readString(din);
      if (str == null)       return null;
 else       return new URL(str);
    }
    private String[] readStringArray(    DataInputStream din) throws IOException {
      int len=din.readInt();
      if (len == 0)       return null;
      String[] str=new String[len];
      for (int i=0; i < len; i++) {
        str[i]=readString(din);
      }
      return str;
    }
    private boolean[] readBooleanArray(    DataInputStream din) throws IOException {
      int len=din.readInt();
      if (len == 0)       return null;
      boolean[] bools=new boolean[len];
      for (int i=0; i < len; i++) {
        bools[i]=din.readBoolean();
      }
      return bools;
    }
    private Properties readMap(    DataInputStream din) throws IOException {
      Properties returnValue=new Properties();
      int count=din.readInt();
      for (int i=0; i < count; i++) {
        String key=readString(din);
        String value=readString(din);
        if (value == null)         value="";
        returnValue.put(key,value);
      }
      return returnValue;
    }
    private void writeString(    DataOutputStream dout,    Object obj) throws IOException {
      if (obj == null) {
        dout.writeInt(0);
      }
 else {
        String str=obj.toString();
        dout.writeInt(str.length());
        dout.writeChars(str);
      }
    }
    private void writeStringArray(    DataOutputStream dout,    String[] str) throws IOException {
      if (str == null) {
        dout.writeInt(0);
      }
 else {
        dout.writeInt(str.length);
        for (int i=0; i < str.length; i++) {
          writeString(dout,str[i]);
        }
      }
    }
    private void writeBooleanArray(    DataOutputStream dout,    boolean[] bools) throws IOException {
      if (bools == null) {
        dout.writeInt(0);
      }
 else {
        dout.writeInt(bools.length);
        for (int i=0; i < bools.length; i++) {
          dout.writeBoolean(bools[i]);
        }
      }
    }
    private void writeMap(    DataOutputStream dout,    Map map) throws IOException {
      dout.writeInt(map.size());
      Iterator iter=map.keySet().iterator();
      while (iter.hasNext()) {
        String key=(String)iter.next();
        writeString(dout,key);
        writeString(dout,map.get(key));
      }
    }
  }
}

-----------------------------LOGGED CLASS-------------------------
public class MiscUtilities {
  public static final String UTF_8_Y="UTF-8Y";
  public static String canonPath(  String path){
    if (path.length() == 0)     return path;
    if (path.startsWith("file://"))     path=path.substring("file://".length());
 else     if (path.startsWith("file:"))     path=path.substring("file:".length());
 else     if (isURL(path))     return path;
    if (File.separatorChar == '\\') {
      path=path.replace('/','\\');
      int trim=path.length();
      while (path.charAt(trim - 1) == ' ')       trim--;
      path=path.substring(0,trim);
    }
 else     if (OperatingSystem.isMacOS()) {
      path=path.replace(':','/');
    }
    if (path.startsWith("~" + File.separator)) {
      path=path.substring(2);
      String home=System.getProperty("user.home");
      if (home.endsWith(File.separator))       return home + path;
 else       return home + File.separator + path;
    }
 else     if (path.equals("~"))     return System.getProperty("user.home");
 else     return path;
  }
  public static String resolveSymlinks(  String path){
    if (isURL(path))     return path;
    if (OperatingSystem.isOS2())     return path;
    if (OperatingSystem.isDOSDerived()) {
      if (path.length() == 2 || path.length() == 3) {
        if (path.charAt(1) == ':')         return path;
      }
    }
    try {
      return new File(path).getCanonicalPath();
    }
 catch (    IOException io) {
      return path;
    }
  }
  public static boolean isAbsolutePath(  String path){
    if (isURL(path))     return true;
 else     if (path.startsWith("~/") || path.startsWith("~" + File.separator) || path.equals("~"))     return true;
 else     if (OperatingSystem.isDOSDerived()) {
      if (path.length() == 2 && path.charAt(1) == ':')       return true;
      if (path.length() > 2 && path.charAt(1) == ':' && (path.charAt(2) == '\\' || path.charAt(2) == '/'))       return true;
      if (path.startsWith("\\\\") || path.startsWith("//"))       return true;
    }
 else     if (OperatingSystem.isUnix() || OperatingSystem.isVMS()) {
      if (path.length() > 0 && path.charAt(0) == '/')       return true;
    }
    return false;
  }
  public static String constructPath(  String parent,  String path){
    if (isAbsolutePath(path))     return canonPath(path);
    if (OperatingSystem.isDOSDerived()) {
      if (path.length() == 2 && path.charAt(1) == ':')       return path;
 else       if (path.length() > 2 && path.charAt(1) == ':' && path.charAt(2) != '\\') {
        path=path.substring(0,2) + '\\' + path.substring(2);
        return canonPath(path);
      }
    }
    String dd=".." + File.separator;
    String d="." + File.separator;
    if (parent == null)     parent=System.getProperty("user.dir");
    for (; ; ) {
      if (path.equals("."))       return parent;
 else       if (path.equals(".."))       return getParentOfPath(parent);
 else       if (path.startsWith(dd) || path.startsWith("../")) {
        parent=getParentOfPath(parent);
        path=path.substring(3);
      }
 else       if (path.startsWith(d) || path.startsWith("./"))       path=path.substring(2);
 else       break;
    }
    if (OperatingSystem.isDOSDerived() && !isURL(parent) && path.startsWith("\\"))     parent=parent.substring(0,2);
    VFS vfs=VFSManager.getVFSForPath(parent);
    return canonPath(vfs.constructPath(parent,path));
  }
  public static String constructPath(  String parent,  String path1,  String path2){
    return constructPath(constructPath(parent,path1),path2);
  }
  public static String concatPath(  String parent,  String path){
    parent=canonPath(parent);
    path=canonPath(path);
    if (path.startsWith(File.separator))     path=path.substring(1);
 else     if ((path.length() >= 3) && (path.charAt(1) == ':'))     path=path.replace(':',File.separatorChar);
    if (parent == null)     parent=System.getProperty("user.dir");
    if (parent.endsWith(File.separator))     return parent + path;
 else     return parent + File.separator + path;
  }
  public static String getFileExtension(  String name){
    int fsIndex=Math.max(name.indexOf('/'),name.indexOf(File.separatorChar));
    int index=name.indexOf('.',fsIndex);
    if (index == -1)     return "";
 else     return name.substring(index);
  }
  public static String getFileName(  String path){
    return VFSManager.getVFSForPath(path).getFileName(path);
  }
  public static String getFileNameNoExtension(  String path){
    String name=getFileName(path);
    int index=name.indexOf('.');
    if (index == -1)     return name;
 else     return name.substring(0,index);
  }
  public static String getFileParent(  String path){
    return getParentOfPath(path);
  }
  public static String getParentOfPath(  String path){
    return VFSManager.getVFSForPath(path).getParentOfPath(path);
  }
  public static String getFileProtocol(  String url){
    return getProtocolOfURL(url);
  }
  public static String getProtocolOfURL(  String url){
    return url.substring(0,url.indexOf(':'));
  }
  public static boolean isURL(  String str){
    int fsIndex=Math.max(str.indexOf(File.separatorChar),str.indexOf('/'));
    if (fsIndex == 0)     return false;
 else     if (fsIndex == 2)     return false;
    int cIndex=str.indexOf(':');
    if (cIndex <= 1)     return false;
 else     if (fsIndex != -1 && cIndex > fsIndex)     return false;
 else     if (cIndex == str.length() - 1) {
      String protocol=str.substring(0,cIndex);
      if (VFSManager.getVFSForProtocol(protocol) == null) {
        return false;
      }
    }
    return true;
  }
  public static void saveBackup(  File file,  int backups,  String backupPrefix,  String backupSuffix,  String backupDirectory){
    saveBackup(file,backups,backupPrefix,backupSuffix,backupDirectory,0);
  }
  public static void saveBackup(  File file,  int backups,  String backupPrefix,  String backupSuffix,  String backupDirectory,  int backupTimeDistance){
    if (backupPrefix == null)     backupPrefix="";
    if (backupSuffix == null)     backupSuffix="";
    String name=file.getName();
    if (backups == 1) {
      File backupFile=new File(backupDirectory,backupPrefix + name + backupSuffix);
      long modTime=backupFile.lastModified();
      if (System.currentTimeMillis() - modTime >= backupTimeDistance) {
        backupFile.delete();
        file.renameTo(backupFile);
      }
    }
 else {
      new File(backupDirectory,backupPrefix + name + backupSuffix+ backups+ backupSuffix).delete();
      File firstBackup=new File(backupDirectory,backupPrefix + name + backupSuffix+ "1"+ backupSuffix);
      long modTime=firstBackup.lastModified();
      if (System.currentTimeMillis() - modTime >= backupTimeDistance) {
        for (int i=backups - 1; i > 0; i--) {
          File backup=new File(backupDirectory,backupPrefix + name + backupSuffix+ i+ backupSuffix);
          backup.renameTo(new File(backupDirectory,backupPrefix + name + backupSuffix+ (i + 1)+ backupSuffix));
        }
        file.renameTo(new File(backupDirectory,backupPrefix + name + backupSuffix+ "1"+ backupSuffix));
      }
    }
  }
  public static String fileToClass(  String name){
    char[] clsName=name.toCharArray();
    for (int i=clsName.length - 6; i >= 0; i--)     if (clsName[i] == '/')     clsName[i]='.';
    return new String(clsName,0,clsName.length - 6);
  }
  public static String classToFile(  String name){
    return name.replace('.','/').concat(".class");
  }
  public static int getLeadingWhiteSpace(  String str){
    int whitespace=0;
    loop:     for (; whitespace < str.length(); ) {
switch (str.charAt(whitespace)) {
case ' ':
case '\t':
        whitespace++;
      break;
default :
    break loop;
}
}
return whitespace;
}
public static int getTrailingWhiteSpace(String str){
int whitespace=0;
loop: for (int i=str.length() - 1; i >= 0; i--) {
switch (str.charAt(i)) {
case ' ':
case '\t':
  whitespace++;
break;
default :
break loop;
}
}
return whitespace;
}
public static int getLeadingWhiteSpaceWidth(String str,int tabSize){
int whitespace=0;
loop: for (int i=0; i < str.length(); i++) {
switch (str.charAt(i)) {
case ' ':
whitespace++;
break;
case '\t':
whitespace+=(tabSize - whitespace % tabSize);
break;
default :
break loop;
}
}
return whitespace;
}
public static int getVirtualWidth(Segment seg,int tabSize){
int virtualPosition=0;
for (int i=0; i < seg.count; i++) {
char ch=seg.array[seg.offset + i];
if (ch == '\t') {
virtualPosition+=tabSize - (virtualPosition % tabSize);
}
 else {
++virtualPosition;
}
}
return virtualPosition;
}
public static int getOffsetOfVirtualColumn(Segment seg,int tabSize,int column,int[] totalVirtualWidth){
int virtualPosition=0;
for (int i=0; i < seg.count; i++) {
char ch=seg.array[seg.offset + i];
if (ch == '\t') {
int tabWidth=tabSize - (virtualPosition % tabSize);
if (virtualPosition >= column) return i;
 else virtualPosition+=tabWidth;
}
 else {
if (virtualPosition >= column) return i;
 else ++virtualPosition;
}
}
if (totalVirtualWidth != null) totalVirtualWidth[0]=virtualPosition;
return -1;
}
public static String createWhiteSpace(int len,int tabSize){
return createWhiteSpace(len,tabSize,0);
}
public static String createWhiteSpace(int len,int tabSize,int start){
StringBuffer buf=new StringBuffer();
if (tabSize == 0) {
while (len-- > 0) buf.append(' ');
}
 else if (len == 1) buf.append(' ');
 else {
int count=(len + start % tabSize) / tabSize;
if (count != 0) len+=start;
while (count-- > 0) buf.append('\t');
count=len % tabSize;
while (count-- > 0) buf.append(' ');
}
return buf.toString();
}
public static String globToRE(String glob){
final Object NEG=new Object();
final Object GROUP=new Object();
Stack state=new Stack();
StringBuffer buf=new StringBuffer();
boolean backslash=false;
for (int i=0; i < glob.length(); i++) {
char c=glob.charAt(i);
if (backslash) {
buf.append('\\');
buf.append(c);
backslash=false;
continue;
}
switch (c) {
case '\\':
backslash=true;
break;
case '?':
buf.append('.');
break;
case '.':
case '+':
case '(':
case ')':
buf.append('\\');
buf.append(c);
break;
case '*':
buf.append(".*");
break;
case '|':
if (backslash) buf.append("\\|");
 else buf.append('|');
break;
case '{':
buf.append('(');
if (i + 1 != glob.length() && glob.charAt(i + 1) == '!') {
buf.append('?');
state.push(NEG);
}
 else state.push(GROUP);
break;
case ',':
if (!state.isEmpty() && state.peek() == GROUP) buf.append('|');
 else buf.append(',');
break;
case '}':
if (!state.isEmpty()) {
buf.append(")");
if (state.pop() == NEG) buf.append(".*");
}
 else buf.append('}');
break;
default :
buf.append(c);
}
}
return buf.toString();
}
public static String escapesToChars(String str){
StringBuffer buf=new StringBuffer();
for (int i=0; i < str.length(); i++) {
char c=str.charAt(i);
switch (c) {
case '\\':
if (i == str.length() - 1) {
buf.append('\\');
break;
}
c=str.charAt(++i);
switch (c) {
case 'n':
buf.append('\n');
break;
case 't':
buf.append('\t');
break;
default :
buf.append(c);
break;
}
break;
default :
buf.append(c);
}
}
return buf.toString();
}
public static String charsToEscapes(String str){
return charsToEscapes(str,"\n\t\\\"'");
}
public static String charsToEscapes(String str,String toEscape){
StringBuffer buf=new StringBuffer();
for (int i=0; i < str.length(); i++) {
char c=str.charAt(i);
if (toEscape.indexOf(c) != -1) {
if (c == '\n') buf.append("\\n");
 else if (c == '\t') buf.append("\\t");
 else {
buf.append('\\');
buf.append(c);
}
}
 else buf.append(c);
}
return buf.toString();
}
public static int compareVersions(String v1,String v2){
return compareStrings(v1,v2,false);
}
public static int compareStrings(String str1,String str2,boolean ignoreCase){
char[] char1=str1.toCharArray();
char[] char2=str2.toCharArray();
int len=Math.min(char1.length,char2.length);
for (int i=0, j=0; i < len && j < len; i++, j++) {
char ch1=char1[i];
char ch2=char2[j];
if (Character.isDigit(ch1) && Character.isDigit(ch2) && ch1 != '0' && ch2 != '0') {
int _i=i + 1;
int _j=j + 1;
for (; _i < char1.length; _i++) {
if (!Character.isDigit(char1[_i])) {
break;
}
}
for (; _j < char2.length; _j++) {
if (!Character.isDigit(char2[_j])) {
break;
}
}
int len1=_i - i;
int len2=_j - j;
if (len1 > len2) return 1;
 else if (len1 < len2) return -1;
 else {
for (int k=0; k < len1; k++) {
ch1=char1[i + k];
ch2=char2[j + k];
if (ch1 != ch2) return ch1 - ch2;
}
}
i=_i - 1;
j=_j - 1;
}
 else {
if (ignoreCase) {
ch1=Character.toLowerCase(ch1);
ch2=Character.toLowerCase(ch2);
}
if (ch1 != ch2) return ch1 - ch2;
}
}
return char1.length - char2.length;
}
public static boolean stringsEqual(String s1,String s2){
return objectsEqual(s1,s2);
}
public static boolean objectsEqual(Object o1,Object o2){
if (o1 == null) {
if (o2 == null) return true;
 else return false;
}
 else if (o2 == null) return false;
 else return o1.equals(o2);
}
public static String charsToEntities(String str){
StringBuffer buf=new StringBuffer(str.length());
for (int i=0; i < str.length(); i++) {
char ch=str.charAt(i);
switch (ch) {
case '<':
buf.append("&lt;");
break;
case '>':
buf.append("&gt;");
break;
case '&':
buf.append("&amp;");
break;
default :
buf.append(ch);
break;
}
}
return buf.toString();
}
public static final DecimalFormat KB_FORMAT=new DecimalFormat("#.# KB");
public static final DecimalFormat MB_FORMAT=new DecimalFormat("#.# MB");
public static String formatFileSize(long length){
if (length < 1024) return length + " bytes";
 else if (length < 1024 * 1024) return KB_FORMAT.format((double)length / 1024);
 else return MB_FORMAT.format((double)length / 1024 / 1024);
}
public static String getLongestPrefix(List str,boolean ignoreCase){
if (str.size() == 0) return "";
int prefixLength=0;
loop: for (; ; ) {
String s=str.get(0).toString();
if (prefixLength >= s.length()) break loop;
char ch=s.charAt(prefixLength);
for (int i=1; i < str.size(); i++) {
s=str.get(i).toString();
if (prefixLength >= s.length()) break loop;
if (!compareChars(s.charAt(prefixLength),ch,ignoreCase)) break loop;
}
prefixLength++;
}
return str.get(0).toString().substring(0,prefixLength);
}
public static String getLongestPrefix(String[] str,boolean ignoreCase){
return getLongestPrefix((Object[])str,ignoreCase);
}
public static String getLongestPrefix(Object[] str,boolean ignoreCase){
if (str.length == 0) return "";
int prefixLength=0;
String first=str[0].toString();
loop: for (; ; ) {
if (prefixLength >= first.length()) break loop;
char ch=first.charAt(prefixLength);
for (int i=1; i < str.length; i++) {
String s=str[i].toString();
if (prefixLength >= s.length()) break loop;
if (!compareChars(s.charAt(prefixLength),ch,ignoreCase)) break loop;
}
prefixLength++;
}
return first.substring(0,prefixLength);
}
public static void quicksort(Object[] obj,Comparator compare){
Arrays.sort(obj,compare);
}
public static void quicksort(Vector vector,Comparator compare){
Collections.sort(vector,compare);
}
public static void quicksort(List list,Comparator compare){
Collections.sort(list,compare);
}
public static void quicksort(Object[] obj,Compare compare){
Arrays.sort(obj,compare);
}
public static void quicksort(Vector vector,Compare compare){
Collections.sort(vector,compare);
}
public interface Compare extends Comparator {
int compare(Object obj1,Object obj2);
}
public static class StringCompare implements Compare {
public int compare(Object obj1,Object obj2){
return compareStrings(obj1.toString(),obj2.toString(),false);
}
}
public static class StringICaseCompare implements Compare {
public int compare(Object obj1,Object obj2){
return compareStrings(obj1.toString(),obj2.toString(),true);
}
}
public static class MenuItemCompare implements Compare {
public int compare(Object obj1,Object obj2){
return compareStrings(((JMenuItem)obj1).getText(),((JMenuItem)obj2).getText(),true);
}
}
public static String buildToVersion(String build){
if (build.length() != 11) return "<unknown version: " + build + ">";
int major=Integer.parseInt(build.substring(0,2));
int minor=Integer.parseInt(build.substring(3,5));
int beta=Integer.parseInt(build.substring(6,8));
int bugfix=Integer.parseInt(build.substring(9,11));
return major + "." + minor+ (beta != 99 ? "pre" + beta : (bugfix != 0 ? "." + bugfix : "final"));
}
public static boolean isToolsJarAvailable(){
Vector paths=new Vector();
paths.addElement("System classpath: " + System.getProperty("java.class.path"));
try {
try {
Class.forName("sun.tools.javac.Main");
}
 catch (ClassNotFoundException e1) {
Class.forName("com.sun.tools.javac.Main");
}
return true;
}
 catch (ClassNotFoundException e) {
}
String settingsDir=jEdit.getSettingsDirectory();
if (settingsDir != null) {
String toolsPath=constructPath(settingsDir,"jars","tools.jar");
paths.addElement(toolsPath);
if (new File(toolsPath).exists()) {
return true;
}
}
String jEditDir=jEdit.getJEditHome();
if (jEditDir != null) {
String toolsPath=constructPath(jEditDir,"jars","tools.jar");
paths.addElement(toolsPath);
if (new File(toolsPath).exists()) {
return true;
}
}
String toolsPath=System.getProperty("java.home");
if (toolsPath.toLowerCase().endsWith(File.separator + "jre")) toolsPath=toolsPath.substring(0,toolsPath.length() - 4);
toolsPath=constructPath(toolsPath,"lib","tools.jar");
paths.addElement(toolsPath);
if (!(new File(toolsPath).exists())) {
return false;
}
PluginJAR jar=jEdit.getPluginJAR(toolsPath);
if (jar == null) {
jEdit.addPluginJAR(toolsPath);
}
 else return true;
}
public static int parsePermissions(String s){
int permissions=0;
if (s.length() == 9) {
if (s.charAt(0) == 'r') permissions+=0400;
if (s.charAt(1) == 'w') permissions+=0200;
if (s.charAt(2) == 'x') permissions+=0100;
 else if (s.charAt(2) == 's') permissions+=04100;
 else if (s.charAt(2) == 'S') permissions+=04000;
if (s.charAt(3) == 'r') permissions+=040;
if (s.charAt(4) == 'w') permissions+=020;
if (s.charAt(5) == 'x') permissions+=010;
 else if (s.charAt(5) == 's') permissions+=02010;
 else if (s.charAt(5) == 'S') permissions+=02000;
if (s.charAt(6) == 'r') permissions+=04;
if (s.charAt(7) == 'w') permissions+=02;
if (s.charAt(8) == 'x') permissions+=01;
 else if (s.charAt(8) == 't') permissions+=01001;
 else if (s.charAt(8) == 'T') permissions+=01000;
}
return permissions;
}
public static String[] getEncodings(){
List returnValue=new ArrayList();
if (OperatingSystem.hasJava14()) {
try {
Class clazz=Class.forName("java.nio.charset.Charset");
Method method=clazz.getMethod("availableCharsets",new Class[0]);
Map map=(Map)method.invoke(null,new Object[0]);
Iterator iter=map.keySet().iterator();
returnValue.add(UTF_8_Y);
while (iter.hasNext()) {
returnValue.add(iter.next());
}
}
 catch (Exception e) {
}
}
 else {
StringTokenizer st=new StringTokenizer(jEdit.getProperty("encodings"));
while (st.hasMoreTokens()) {
returnValue.add(st.nextToken());
}
}
return (String[])returnValue.toArray(new String[returnValue.size()]);
}
public static boolean isSupportedEncoding(String encoding){
if (OperatingSystem.hasJava14()) {
try {
Class clazz=Class.forName("java.nio.charset.Charset");
Method method=clazz.getMethod("isSupported",new Class[]{String.class});
return ((Boolean)method.invoke(null,new Object[]{encoding})).booleanValue();
}
 catch (Exception e) {
Log.log(Log.ERROR,MiscUtilities.class,e);
}
}
return true;
}
public static String throwableToString(Throwable t){
StringWriter s=new StringWriter();
t.printStackTrace(new PrintWriter(s));
return s.toString();
}
private MiscUtilities(){
}
private static boolean compareChars(char ch1,char ch2,boolean ignoreCase){
if (ignoreCase) return Character.toUpperCase(ch1) == Character.toUpperCase(ch2);
 else return ch1 == ch2;
}
}
-----------------------------LOGGED CLASS-------------------------
public class EditBus {
  public static void addToBus(  EBComponent comp){
synchronized (components) {
      components.add(comp);
      copyComponents=null;
    }
  }
  public static void removeFromBus(  EBComponent comp){
synchronized (components) {
      components.remove(comp);
      copyComponents=null;
    }
  }
  public static EBComponent[] getComponents(){
synchronized (components) {
      if (copyComponents == null) {
        copyComponents=(EBComponent[])components.toArray(new EBComponent[components.size()]);
      }
      return copyComponents;
    }
  }
  public static void send(  EBMessage message){
    EBComponent[] comps=getComponents();
    for (int i=0; i < comps.length; i++) {
      try {
        EBComponent comp=comps[i];
        if (Debug.EB_TIMER) {
          long start=System.currentTimeMillis();
          comp.handleMessage(message);
          long time=(System.currentTimeMillis() - start);
          if (time != 0) {
            Log.log(Log.DEBUG,EditBus.class,comp + ": " + time+ " ms");
          }
        }
 else         comps[i].handleMessage(message);
      }
 catch (      Throwable t) {
      }
    }
  }
  private static ArrayList components=new ArrayList();
  private static EBComponent[] copyComponents;
  private EditBus(){
  }
}

-----------------------------LOGGED CLASS-------------------------
public class EditBus {
  public static void addToBus(  EBComponent comp){
synchronized (components) {
      components.add(comp);
      copyComponents=null;
    }
  }
  public static void removeFromBus(  EBComponent comp){
synchronized (components) {
      components.remove(comp);
      copyComponents=null;
    }
  }
  public static EBComponent[] getComponents(){
synchronized (components) {
      if (copyComponents == null) {
        copyComponents=(EBComponent[])components.toArray(new EBComponent[components.size()]);
      }
      return copyComponents;
    }
  }
  public static void send(  EBMessage message){
    Log.log(Log.DEBUG,EditBus.class,message.toString());
    EBComponent[] comps=getComponents();
    for (int i=0; i < comps.length; i++) {
      try {
        EBComponent comp=comps[i];
        if (Debug.EB_TIMER) {
          long start=System.currentTimeMillis();
          comp.handleMessage(message);
          long time=(System.currentTimeMillis() - start);
          if (time != 0) {
          }
        }
 else         comps[i].handleMessage(message);
      }
 catch (      Throwable t) {
      }
    }
  }
  private static ArrayList components=new ArrayList();
  private static EBComponent[] copyComponents;
  private EditBus(){
  }
}
-----------------------------LOGGED CLASS-------------------------
public static class Wrapper implements ActionListener {
  public Wrapper(  ActionContext context,  String actionName){
    this.context=context;
    this.actionName=actionName;
  }
  public void actionPerformed(  ActionEvent evt){
    EditAction action=context.getAction(actionName);
    if (action == null) {
      Log.log(Log.WARNING,this,"Unknown action: " + actionName);
    }
 else     context.invokeAction(evt,action);
  }
  private ActionContext context;
  private String actionName;
}

-----------------------------LOGGED CLASS-------------------------
public abstract class EBPlugin extends EditPlugin implements EBComponent {
  public void handleMessage(  EBMessage message){
    EditBus.removeFromBus(this);
    if (seenWarning)     return;
    seenWarning=true;
    Log.log(Log.WARNING,this,getClassName() + " should extend" + " EditPlugin not EBPlugin since it has an empty"+ " handleMessage()");
  }
  protected EBPlugin(){
  }
  private boolean seenWarning;
}

-----------------------------LOGGED CLASS-------------------------
static class RecentHandler extends HandlerBase {
  public void endDocument() throws java.lang.Exception {
    int max=jEdit.getIntegerProperty("recentFiles",50);
    while (history.size() > max)     history.removeLast();
  }
  public Object resolveEntity(  String publicId,  String systemId){
    if ("recent.dtd".equals(systemId)) {
      return new StringReader("<!-- -->");
    }
    return null;
  }
  public void doctypeDecl(  String name,  String publicId,  String systemId) throws Exception {
    if ("RECENT".equals(name))     return;
    Log.log(Log.ERROR,this,"recent.xml: DOCTYPE must be RECENT");
  }
  public void endElement(  String name){
    if (name.equals("ENTRY")) {
      history.addLast(new Entry(path,caret,selection,encoding));
      path=null;
      caret=0;
      selection=null;
      encoding=null;
    }
 else     if (name.equals("PATH"))     path=charData;
 else     if (name.equals("CARET"))     caret=Integer.parseInt(charData);
 else     if (name.equals("SELECTION"))     selection=charData;
 else     if (name.equals("ENCODING"))     encoding=charData;
  }
  public void charData(  char[] ch,  int start,  int length){
    charData=new String(ch,start,length);
  }
  private String path;
  private int caret;
  private String selection;
  private String encoding;
  private String charData;
}

-----------------------------LOGGED CLASS-------------------------
public class JARClassLoader extends ClassLoader {
  public JARClassLoader(){
    id=INDEX++;
    live++;
  }
  public Class loadClass(  String clazz,  boolean resolveIt) throws ClassNotFoundException {
    Object obj=classHash.get(clazz);
    if (obj == NO_CLASS) {
      throw new ClassNotFoundException(clazz);
    }
 else     if (obj instanceof JARClassLoader) {
      JARClassLoader classLoader=(JARClassLoader)obj;
      return classLoader._loadClass(clazz,resolveIt);
    }
    try {
      Class cls;
      ClassLoader parentLoader=getClass().getClassLoader();
      if (parentLoader != null)       cls=parentLoader.loadClass(clazz);
 else       cls=findSystemClass(clazz);
      return cls;
    }
 catch (    ClassNotFoundException cnf) {
      classHash.put(clazz,NO_CLASS);
      throw cnf;
    }
  }
  public InputStream getResourceAsStream(  String name){
    if (jar == null)     return null;
    try {
      ZipFile zipFile=jar.getZipFile();
      ZipEntry entry=zipFile.getEntry(name);
      if (entry == null)       return getSystemResourceAsStream(name);
 else       return zipFile.getInputStream(entry);
    }
 catch (    IOException io) {
      return null;
    }
  }
  public URL getResource(  String name){
    if (jar == null)     return null;
    try {
      ZipFile zipFile=jar.getZipFile();
      ZipEntry entry=zipFile.getEntry(name);
      if (entry == null)       return getSystemResource(name);
 else       return new URL(getResourceAsPath(name));
    }
 catch (    IOException io) {
      return null;
    }
  }
  public String getResourceAsPath(  String name){
    if (jar == null)     return null;
    if (!name.startsWith("/"))     name="/" + name;
    return "jeditresource:/" + MiscUtilities.getFileName(jar.getPath()) + "!"+ name;
  }
  public ZipFile getZipFile(){
    try {
      return jar.getZipFile();
    }
 catch (    IOException io) {
      return null;
    }
  }
  public static void dump(){
synchronized (classHash) {
      Iterator entries=classHash.entrySet().iterator();
      while (entries.hasNext()) {
        Map.Entry entry=(Map.Entry)entries.next();
        if (entry.getValue() != NO_CLASS) {
        }
      }
    }
  }
  public String toString(){
    if (jar == null)     return "<anonymous>(" + id + ")";
 else     return jar.getPath() + " (" + id+ ")";
  }
  protected void finalize(){
    live--;
  }
  JARClassLoader(  PluginJAR jar){
    this();
    this.jar=jar;
  }
  void activate(){
    String[] classes=jar.getClasses();
    if (classes != null) {
      for (int i=0; i < classes.length; i++) {
        classHash.put(classes[i],this);
      }
    }
  }
  void deactivate(){
    String[] classes=jar.getClasses();
    if (classes == null)     return;
    for (int i=0; i < classes.length; i++) {
      Object loader=classHash.get(classes[i]);
      if (loader == this)       classHash.remove(classes[i]);
 else       ;
    }
  }
  private static final Object NO_CLASS=new Object();
  private static int INDEX;
  private static int live;
  private static Hashtable classHash=new Hashtable();
  private int id;
  private PluginJAR jar;
  private synchronized Class _loadClass(  String clazz,  boolean resolveIt) throws ClassNotFoundException {
    jar.activatePlugin();
synchronized (this) {
      Class cls=findLoadedClass(clazz);
      if (cls != null) {
        if (resolveIt)         resolveClass(cls);
        return cls;
      }
      String name=MiscUtilities.classToFile(clazz);
      try {
        ZipFile zipFile=jar.getZipFile();
        ZipEntry entry=zipFile.getEntry(name);
        if (entry == null)         throw new ClassNotFoundException(clazz);
        InputStream in=zipFile.getInputStream(entry);
        int len=(int)entry.getSize();
        byte[] data=new byte[len];
        int success=0;
        int offset=0;
        while (success < len) {
          len-=success;
          offset+=success;
          success=in.read(data,offset,len);
          if (success == -1) {
            Log.log(Log.ERROR,this,"Failed to load class " + clazz + " from "+ zipFile.getName());
            throw new ClassNotFoundException(clazz);
          }
        }
        cls=defineClass(clazz,data,0,data.length);
        if (resolveIt)         resolveClass(cls);
        return cls;
      }
 catch (      IOException io) {
        throw new ClassNotFoundException(clazz);
      }
    }
  }
}
-----------------------------LOGGED CLASS-------------------------
static class RootsEntry extends VFS.DirectoryEntry {
  RootsEntry(  File file){
    this.path=this.deletePath=this.symlinkPath=file.getPath();
    if (isFloppy(file)) {
      type=VFS.DirectoryEntry.FILESYSTEM;
      name=path;
    }
 else     if (isDrive(file)) {
      type=VFS.DirectoryEntry.FILESYSTEM;
      if (getSystemDisplayName != null) {
        try {
          name=path + " " + (String)getSystemDisplayName.invoke(fsView,new Object[]{file});
        }
 catch (        Exception e) {
          Log.log(Log.ERROR,this,e);
          name=path;
        }
      }
    }
 else     if (file.isDirectory()) {
      type=VFS.DirectoryEntry.FILESYSTEM;
      if (isFileSystemRoot != null) {
        try {
          if (Boolean.FALSE.equals(isFileSystemRoot.invoke(fsView,new Object[]{file}))) {
            type=VFS.DirectoryEntry.DIRECTORY;
          }
        }
 catch (        Exception e) {
        }
      }
      if (OperatingSystem.isMacOS())       name=MiscUtilities.getFileName(path);
 else       name=path;
    }
 else     type=VFS.DirectoryEntry.FILE;
  }
  public String getExtendedAttribute(  String name){
    if (name.equals(EA_TYPE))     return super.getExtendedAttribute(name);
 else {
      return null;
    }
  }
  private boolean isFloppy(  File file){
    if (isFloppyDrive != null) {
      try {
        return Boolean.TRUE.equals(isFloppyDrive.invoke(fsView,new Object[]{file}));
      }
 catch (      Exception e) {
        return false;
      }
    }
 else     return path.startsWith("A:") || path.startsWith("B:");
  }
  private boolean isDrive(  File file){
    if (isDrive != null) {
      try {
        return Boolean.TRUE.equals(isDrive.invoke(fsView,new Object[]{file}));
      }
 catch (      Exception e) {
        return false;
      }
    }
 else     return true;
  }
}

-----------------------------LOGGED CLASS-------------------------
public class ServiceManager {
  public static void loadServices(  PluginJAR plugin,  URL uri,  PluginJAR.PluginCacheEntry cache){
    Reader in=null;
    try {
      ServiceListHandler dh=new ServiceListHandler(plugin,uri);
      XmlParser parser=new XmlParser();
      parser.setHandler(dh);
      in=new BufferedReader(new InputStreamReader(uri.openStream()));
      parser.parse(null,null,in);
      if (cache != null)       cache.cachedServices=dh.getCachedServices();
    }
 catch (    XmlException xe) {
      int line=xe.getLine();
      String message=xe.getMessage();
      Log.log(Log.ERROR,ServiceManager.class,uri + ":" + line+ ": "+ message);
    }
catch (    Exception e) {
    }
 finally {
      try {
        if (in != null)         in.close();
      }
 catch (      IOException io) {
      }
    }
  }
  public static void unloadServices(  PluginJAR plugin){
    Iterator descriptors=serviceMap.keySet().iterator();
    while (descriptors.hasNext()) {
      Descriptor d=(Descriptor)descriptors.next();
      if (d.plugin == plugin)       descriptors.remove();
    }
  }
  public static void registerService(  String clazz,  String name,  String code,  PluginJAR plugin){
    Descriptor d=new Descriptor(clazz,name,code,plugin);
    serviceMap.put(d,d);
  }
  public static void unregisterService(  String clazz,  String name){
    Descriptor d=new Descriptor(clazz,name);
    serviceMap.remove(d);
  }
  public static String[] getServiceTypes(){
    HashSet returnValue=new HashSet();
    Iterator descriptors=serviceMap.keySet().iterator();
    while (descriptors.hasNext()) {
      Descriptor d=(Descriptor)descriptors.next();
      returnValue.add(d.clazz);
    }
    return (String[])returnValue.toArray(new String[returnValue.size()]);
  }
  public static String[] getServiceNames(  String clazz){
    ArrayList returnValue=new ArrayList();
    Iterator descriptors=serviceMap.keySet().iterator();
    while (descriptors.hasNext()) {
      Descriptor d=(Descriptor)descriptors.next();
      if (d.clazz.equals(clazz))       returnValue.add(d.name);
    }
    return (String[])returnValue.toArray(new String[returnValue.size()]);
  }
  public static Object getService(  String clazz,  String name){
    Descriptor key=new Descriptor(clazz,name);
    Descriptor value=(Descriptor)serviceMap.get(key);
    if (value == null) {
      return null;
    }
 else {
      if (value.code == null) {
        loadServices(value.plugin,value.plugin.getServicesURI(),null);
        value=(Descriptor)serviceMap.get(key);
      }
      return value.getInstance();
    }
  }
  static void registerService(  Descriptor d){
    serviceMap.put(d,d);
  }
  private static Map serviceMap=new HashMap();
static class Descriptor {
    String clazz;
    String name;
    String code;
    PluginJAR plugin;
    Object instance;
    boolean instanceIsNull;
    Descriptor(    String clazz,    String name){
      this.clazz=clazz;
      this.name=name;
    }
    Descriptor(    String clazz,    String name,    String code,    PluginJAR plugin){
      this.clazz=clazz;
      this.name=name;
      this.code=code;
      this.plugin=plugin;
    }
    Object getInstance(){
      if (instanceIsNull)       return null;
 else       if (instance == null) {
        instance=BeanShell.eval(null,BeanShell.getNameSpace(),code);
        if (instance == null) {
          instanceIsNull=true;
        }
      }
      return instance;
    }
    public int hashCode(){
      return name.hashCode();
    }
    public boolean equals(    Object o){
      if (o instanceof Descriptor) {
        Descriptor d=(Descriptor)o;
        return d.clazz.equals(clazz) && d.name.equals(name);
      }
 else       return false;
    }
  }
}

